{
  "Template": {
    "prefix": "temp",
    "body": [
      "#include <cmath>",
      "#include <cstdio>",
      "#include <cstdlib>",
      "#include <cstring>",
      "",
      "#include <algorithm>",
      "#include <bitset>",
      "#include <complex>",
      "#include <iostream>",
      "#include <map>",
      "#include <numeric>",
      "#include <queue>",
      "#include <set>",
      "#include <stack>",
      "#include <string>",
      "#include <unordered_map>",
      "#include <unordered_set>",
      "#include <vector>",
      "",
      "#include <cassert>",
      "#include <functional>",
      "",
      "typedef long long ll;",
      "using namespace std;",
      "",
      "#ifndef LOCAL",
      "#define debug(...) ;",
      "#else",
      "#define debug(...) cerr << __LINE__ << \" : \" << #__VA_ARGS__ << \" = \" << _tostr(__VA_ARGS__) << endl;",
      "",
      "template<typename T>",
      "ostream &operator<<(ostream &out, const vector<T> &v);",
      "",
      "template<typename T1, typename T2>",
      "ostream &operator<<(ostream &out, const pair<T1, T2> &p) {",
      "  out << \"{\" << p.first << \", \" << p.second << \"}\";",
      "  return out;",
      "}",
      "",
      "template<typename T>",
      "ostream &operator<<(ostream &out, const vector<T> &v) {",
      "  out << '{';",
      "  for (const T &item : v) out << item << \", \";",
      "  out << \"\\b\\b}\";",
      "  return out;",
      "}",
      "",
      "void _tostr_rec(ostringstream &oss) {",
      "  oss << \"\\b\\b \\b\";",
      "}",
      "",
      "template<typename Head, typename... Tail>",
      "void _tostr_rec(ostringstream &oss, Head &&head, Tail &&...tail) {",
      "  oss << head << \", \";",
      "  _tostr_rec(oss, forward<Tail>(tail)...);",
      "}",
      "",
      "template<typename... T>",
      "string _tostr(T &&...args) {",
      "  ostringstream oss;",
      "  int size = sizeof...(args);",
      "  if (size > 1) oss << \"{\";",
      "  _tostr_rec(oss, forward<T>(args)...);",
      "  if (size > 1) oss << \"}\";",
      "  return oss.str();",
      "}",
      "#endif",
      "",
      "#define mod 1000000007 //1e9+7(prime number)",
      "#define INF 1000000000 //1e9",
      "#define LLINF 2000000000000000000LL //2e18",
      "#define SIZE 200010",
      "",
      "",
      "int main() {",
      "  return 0;",
      "}"
    ],
    "description": "Template"
  },
  "Sign": {
    "prefix": "sign",
    "body": [
      "int sign(ll x) {",
      "  return (x > 0) - (x < 0);",
      "}"
    ],
    "description": "Sign"
  },
  "GCD-LCM": {
    "prefix": "gcdlcm",
    "body": [
      "// GCC __gcd(long long A, long long B)",
      "",
      "ll gcd(ll a, ll b) {",
      "  if (a == 0) return b;",
      "  return gcd(b % a, a);",
      "}",
      "",
      "ll lcm(ll a, ll b) {",
      "  return a / gcd(a, b) * b;",
      "}"
    ],
    "description": "GCD-LCM"
  },
  "Extended GCD": {
    "prefix": "extgcd",
    "body": [
      "// {a, {b, c}} : a = gcd(p, q) = bp + cq",
      "pair<ll, pair<ll, ll>> ext_gcd(ll p, ll q) {",
      "  if (q == 0) return {p, {1, 0}};",
      "  auto r = ext_gcd(q, p % q);",
      "  return {r.first, {r.second.second, r.second.first - p / q * r.second.second}};",
      "}"
    ],
    "description": "Extended GCD"
  },
  "Divisor": {
    "prefix": "divisor",
    "body": [
      "template<typename T>",
      "vector<T> divisor(T n) {",
      "  vector<T> res, res2;",
      "  for (T i = 1; i * i <= n; i++) {",
      "    if (n % i == 0) {",
      "      res.push_back(i);",
      "      if (i * i < n) res2.push_back(n / i);",
      "    }",
      "  }",
      "",
      "  reverse(res2.begin(), res2.end());",
      "  res.insert(res.end(), res2.begin(), res2.end());",
      "",
      "  return res;",
      "}"
    ],
    "description": "Divisor"
  },
  "Power": {
    "prefix": "power",
    "body": [
      "ll power(ll k, ll n, int M) {",
      "  ll res = 1;",
      "  while (n > 0) {",
      "    if (n & 1) res = res * k % M;",
      "    k = k * k % M;",
      "    n /= 2;",
      "  }",
      "  return res;",
      "}"
    ],
    "description": "Power"
  },
  "Combination,Permutation": {
    "prefix": "pch",
    "body": [
      "vector<ll> factmemo, factmemoInv;",
      "ll factmemoMod = -1;",
      "",
      "ll factorial(int n, int M) {",
      "  if (factmemoMod == M) return factmemo[n];",
      "  if (n <= 1) return 1;",
      "",
      "  ll res = 1;",
      "  for (int i = 1; i <= n; i++) res = res * i % M;",
      "  return res;",
      "}",
      "",
      "ll power(ll k, ll n, int M) {",
      "  ll res = 1;",
      "  while (n > 0) {",
      "    if (n & 1) res = res * k % M;",
      "    k = k * k % M;",
      "    n /= 2;",
      "  }",
      "  return res;",
      "}",
      "",
      "void initFactorial(int n, int M) {",
      "  factmemo.assign(n + 1, 0);",
      "  factmemoInv.assign(n + 1, 0);",
      "  factmemoMod = M;",
      "  factmemo[0] = 1;",
      "  for (int i = 1; i <= n; i++) factmemo[i] = factmemo[i - 1] * i % M;",
      "  factmemoInv[n] = power(factmemo[n], M - 2, M);",
      "  for (int i = n; i > 0; i--) factmemoInv[i - 1] = factmemoInv[i] * i % M;",
      "}",
      "",
      "//nCm nPm nHm (mod M)",
      "",
      "/*Combination*/",
      "ll C(int n, int m, int M) {",
      "  if (n < m) return 0;",
      "  if (m == 0 || n == m) return 1;",
      "",
      "  if (factmemoMod == M)",
      "    return factmemo[n] * factmemoInv[m] % M * factmemoInv[n - m] % M;",
      "",
      "  ll numer = factorial(n, M);",
      "  ll denom = factorial(m, M) * factorial(n - m, M) % M;",
      "",
      "  denom = power((int)denom, M - 2, M);",
      "",
      "  return numer * denom % M;",
      "}",
      "/*Permutation*/",
      "ll P(int n, int m, int M) {",
      "  if (n < m) return 0;",
      "  if (m == 0) return 1;",
      "",
      "  if (factmemoMod == M)",
      "    return factmemo[n] * factmemoInv[n - m] % M;",
      "",
      "  ll numer = factorial(n, M);",
      "  ll denom = factorial(n - m, M);",
      "",
      "  denom = power((int)denom, M - 2, M);",
      "",
      "  return numer * denom % M;",
      "}",
      "/*Combination with Repetitions*/",
      "ll H(int n, int m, int M) {",
      "  if (n == 0 && m == 0) return 1;",
      "  return C(n + m - 1, m, M);",
      "}"
    ],
    "description": "Combination,Permutation"
  },
  "Permutation Converter": {
    "prefix": "permutation",
    "body": [
      "/* Permutation <-> ID */",
      "// {0,1,2} <=> 0, {0,2,1} <=> 1, {2, 1, 0} <=> 5",
      "",
      "namespace PermutationConverter {",
      "  const int MAX_DATASIZE = 20;",
      "",
      "  ll encode(int N, int *data) {",
      "    bool used[MAX_DATASIZE] = {};",
      "    ll id = 0, t = 1;",
      "",
      "    for (int i = 1; i <= N; i++) t *= i;",
      "",
      "    for (int i = 0; i < N; i++) {",
      "      t /= (N - i);",
      "      used[data[i]] = true;",
      "      id += count(used, used + data[i], false) * t;",
      "    }",
      "",
      "    return id;",
      "  }",
      "",
      "  void decode(int N, ll id, int *data) {",
      "    bool used[MAX_DATASIZE] = {};",
      "    ll t = 1;",
      "",
      "    for (int i = 1; i <= N; i++) t *= i;",
      "",
      "    for (int i = 0; i < N; i++) {",
      "      t /= (N - i);",
      "",
      "      int s = id / t;",
      "      for (int j = 0;; j++) {",
      "        if (!used[j] && s == 0) {",
      "          data[i] = j;",
      "          used[j] = true;",
      "          break;",
      "        }",
      "        s -= !used[j];",
      "      }",
      "",
      "      id %= t;",
      "    }",
      "  }",
      "};"
    ],
    "description": "Permutation Converter"
  },
  "Sieve of Eratosthenes": {
    "prefix": "eratos",
    "body": [
      "vector<bool> isPrime;",
      "",
      "void Eratosthenes(int N) {",
      "  isPrime.assign(N + 1, true);",
      "  isPrime[0] = isPrime[1] = false;",
      "",
      "  for (int i = 2; i * i <= N; i++)",
      "    if (isPrime[i])",
      "      for (int j = i; i * j <= N; j++)",
      "        isPrime[i * j] = false;",
      "}"
    ],
    "description": "Sieve of Eratosthenes"
  },
  "Miller-Rabin Primality Test": {
    "prefix": "millerrabin",
    "body": [
      "/* \u30df\u30e9\u30fc-\u30e9\u30d3\u30f3\u7d20\u6570\u5224\u5b9a\u6cd5 */",
      "",
      "namespace MillerRabin {",
      "  typedef __int128_t Int;",
      "  Int power(Int k, Int n, ll M) {",
      "    if (n == 0) return 1;",
      "    if (n == 1) return k % M;",
      "",
      "    Int res = power(k, n / 2, M);",
      "    res = res * res % M;",
      "    return n % 2 ? res % M * k % M : res;",
      "  }",
      "",
      "  bool isPrime(ll x) {",
      "    int a[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, -1}; // x < 2^64",
      "    //int a[] = {2, 7, 61, -1}; // x < 2^32",
      "    if (x == 2) return true;",
      "    if (x <= 1 || x % 2 == 0) return false;",
      "    Int d = x - 1;",
      "    int s = 0;",
      "    for (; d % 2 == 0; s++) d >>= 1;",
      "    for (int i = 0; a[i] != -1 && a[i] < x; i++) {",
      "      Int y = power(a[i], d, x);",
      "      if (y == 1) continue;",
      "      for (int j = 0; j < s - 1 && y != x - 1; j++) y = (y * y) % x;",
      "      if (y != x - 1) return false;",
      "    }",
      "    return true;",
      "  }",
      "};"
    ],
    "description": "Miller-Rabin Primality Test"
  },
  "Euler\\'s Phi Function": {
    "prefix": "eulerphi",
    "body": [
      "/* \u30aa\u30a4\u30e9\u30fc\u306e\u03a6\u95a2\u6570 */",
      "// n\u3068\u4e92\u3044\u306b\u7d20\u306an\u4ee5\u4e0b\u306e\u6570\u306e\u500b\u6570",
      "",
      "// power(a, phi(n)-1) * a = 1",
      "// (gcd(a, n) = 1)",
      "",
      "ll eulerPhi(ll n) {",
      "  if (n <= 0) return 0;",
      "  ll res = n;",
      "  for (int i = 2; i * i <= n; i++) {",
      "    if (n % i == 0) {",
      "      res -= res / i;",
      "      while (n % i == 0) n /= i;",
      "    }",
      "  }",
      "  if (n > 1) res -= res / n;",
      "  return res;",
      "}",
      "",
      "vector<int> eulerPhiTable(int n) {",
      "  vector<int> phi(n + 1);",
      "  iota(phi.begin(), phi.end(), 0);",
      "",
      "  for (int i = 2; i <= n; i++)",
      "    if (phi[i] == i)",
      "      for (int j = 1; j * i <= n; j++)",
      "        phi[i * j] -= phi[i * j] / i;",
      "",
      "  return phi;",
      "}"
    ],
    "description": "Euler\\'s Phi Function"
  },
  "Primitive Root": {
    "prefix": "primitiveroot",
    "body": [
      "ll getPrimitiveRoot(ll P) {",
      "  // assert(isPrime(P));",
      "  if (P == 2) return 1;",
      "  ll p = P - 1;",
      "  vector<ll> a;",
      "",
      "  for (int i = 2; i * i <= p; i++) {",
      "    if (p % i == 0) a.push_back(i);",
      "    while (p % i == 0) p /= i;",
      "  }",
      "  if (p > 1) a.push_back(p);",
      "",
      "  while (1) {",
      "    bool ok = true;",
      "    ll r = rand() % (P - 2) + 2;",
      "    for (auto q : a)",
      "      ok &= power(r, (P - 1) / q, P) != 1;",
      "    if (ok) return r;",
      "  }",
      "}"
    ],
    "description": "Primitive Root"
  },
  "Simultaneous Equation": {
    "prefix": "gauss",
    "body": [
      "/* \u9023\u7acb\u4e00\u6b21\u65b9\u7a0b\u5f0f (Gauss\u6cd5) */",
      "/*",
      "3x + 2y = 7",
      "2x + 5y = 12",
      "double a[2][2]= {{3, 2},{2,5}};",
      "double b[2]={ 7, 12};",
      "",
      "run -> b[2] = {1, 2}",
      "*/",
      "",
      "#define gaussN 2",
      "",
      "void Gauss(double a[gaussN][gaussN], int b[gaussN]) {",
      "  /* a, b\u306e\u4e2d\u8eab\u306f\u7834\u58ca\u3055\u308c\u308b */",
      "  int n = gaussN;",
      "",
      "  for (int k = 0; k < n; k++) {",
      "    for (int j = k + 1; j < n; j++)",
      "      a[k][j] /= a[k][k];",
      "    b[k] /= a[k][k];",
      "",
      "    for (int i = k + 1; i < n; i++) {",
      "      for (int j = k + 1; j < n; j++)",
      "        a[i][j] -= a[k][j] * a[i][k];",
      "      b[i] -= b[k] * a[i][k];",
      "    }",
      "  }",
      "",
      "  for (int k = n - 2; k >= 0; k--)",
      "    for (int j = k + 1; j < n; j++)",
      "      b[k] -= a[k][j] * b[j];",
      "}"
    ],
    "description": "Simultaneous Equation"
  },
  "Fast Zeta Transform": {
    "prefix": "fzt",
    "body": [
      "/* FastZetaTransform */",
      "",
      "// a[1001] = a[1001] + a[1011] + a[1101] + a[1111];",
      "",
      "template<typename T>",
      "void FZT(int n, T *a) {",
      "  for (int i = 0; i < n; i++)",
      "    for (int j = 0; j < (1 << n); j++)",
      "      if (!(j & (1 << i))) a[j] += a[j | (1 << i)]; //\u7dcf\u548c",
      "}",
      "",
      "// a[1001] = a[1001] + a[1000] + a[0001] + a[0000];",
      "",
      "template<typename T>",
      "void FZT2(int n, T *a) {",
      "  for (int i = 0; i < n; i++)",
      "    for (int j = 0; j < (1 << n); j++)",
      "      if (j & (1 << i)) a[j] += a[j ^ (1 << i)]; //\u7dcf\u548c",
      "}"
    ],
    "description": "Fast Zeta Transform"
  },
  "Fast Fourier Transform": {
    "prefix": "fft",
    "body": [
      "/* Fast Fourier Transform */",
      "",
      "namespace FFT {",
      "  using C = complex<double>;",
      "",
      "  void DFT(vector<C> &a, bool rev = false) {",
      "    int N = a.size();",
      "    //const double M_PI = acos(-1);",
      "",
      "    for (int i = 0, j = 1; j + 1 < N; j++) {",
      "      for (int k = N >> 1; k > (i ^= k); k >>= 1)",
      "        ;",
      "      if (i > j) swap(a[i], a[j]);",
      "    }",
      "",
      "    for (int i = 1; i < N; i *= 2) {",
      "      for (int j = 0; j < i; j++) {",
      "        C w = polar(1.0, M_PI / i * (rev ? -1 : 1) * j);",
      "        for (int k = 0; k < N; k += i * 2) {",
      "          C s = a[j + k], t = a[j + k + i] * w;",
      "          a[j + k + 0] = s + t;",
      "          a[j + k + i] = s - t;",
      "        }",
      "      }",
      "    }",
      "",
      "    if (rev)",
      "      for (C &v : a) v /= N;",
      "  }",
      "",
      "  vector<ll> conv(const vector<int> &a, const vector<int> &b) {",
      "    int s = 1, t = a.size() + b.size() - 1;",
      "    while (s < t) s *= 2;",
      "",
      "    vector<C> F(s), G(s);",
      "    for (int i = 0; i < (int)a.size(); i++) F[i] = a[i];",
      "    for (int i = 0; i < (int)b.size(); i++) G[i] = b[i];",
      "    DFT(F);",
      "    DFT(G);",
      "",
      "    for (int i = 0; i < s; i++) F[i] *= G[i];",
      "    DFT(F, true);",
      "",
      "    vector<ll> res(t);",
      "    for (int i = 0; i < t; i++) res[i] = F[i].real() + 0.5; //round",
      "    return res;",
      "  }",
      "};"
    ],
    "description": "Fast Fourier Transform"
  },
  "Number Theoretic Transform": {
    "prefix": "ntt",
    "body": [
      "/* Number Theoretic Transform */",
      "",
      "namespace NTT {",
      "  void DFT(int m, int root, vector<int> &a, bool rev = false) {",
      "    int N = a.size();",
      "",
      "    for (int i = 0, j = 1; j + 1 < N; j++) {",
      "      for (int k = N >> 1; k > (i ^= k); k >>= 1)",
      "        ;",
      "      if (i > j) swap(a[i], a[j]);",
      "    }",
      "",
      "    int g = power(root, (m - 1) / N, m);",
      "    if (rev) g = power(g, m - 2, m);",
      "",
      "    for (int i = 1; i < N; i *= 2) {",
      "      int base = power(g, N / i / 2, m);",
      "      ll w = 1;",
      "      for (int j = 0; j < i; j++) {",
      "        for (int k = 0; k < N; k += i * 2) {",
      "          int s = a[j + k], t = a[j + k + i] * w % m;",
      "          a[j + k + 0] = (s + t) % m;",
      "          a[j + k + i] = (s - t + m) % m;",
      "        }",
      "        w = w * base % m;",
      "      }",
      "    }",
      "",
      "    if (rev) {",
      "      ll tmp = power(N, m - 2, m);",
      "      for (int &v : a) v = v * tmp % m;",
      "    }",
      "  }",
      "",
      "  // (469762049, 3), (924844033, 5), (998244353, 3), (1012924417, 5)",
      "",
      "  vector<int> conv(int _mod, int root, const vector<int> &a, const vector<int> &b) {",
      "    int s = 1, t = a.size() + b.size() - 1;",
      "    while (s < t) s *= 2;",
      "",
      "    vector<int> F(s), G(s);",
      "    for (int i = 0; i < (int)a.size(); i++) F[i] = a[i];",
      "    for (int i = 0; i < (int)b.size(); i++) G[i] = b[i];",
      "    DFT(_mod, root, F);",
      "    DFT(_mod, root, G);",
      "",
      "    for (int i = 0; i < s; i++) F[i] = (ll)F[i] * G[i] % _mod;",
      "    DFT(_mod, root, F, true);",
      "",
      "    return F;",
      "  }",
      "};"
    ],
    "description": "Number Theoretic Transform"
  },
  "Lagrange Interpolation": {
    "prefix": "lagrange",
    "body": [
      "/* \u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u88dc\u9593 */",
      "",
      "// y[i] = f(x[i]) mod P",
      "// 0 <= x[i], y[i] < P",
      "// f = sum(res[i] * x^i)",
      "vector<int> lagrangeInterpolation(const vector<int> &x, const vector<int> &y, int P) {",
      "  int N = x.size();",
      "  vector<ll> Q(N + 1);",
      "  vector<int> res(N);",
      "",
      "  Q[0] = 1;",
      "  for (int i = 0; i < N; i++) {",
      "    for (int j = i; j >= 0; j--) {",
      "      Q[j + 1] = (Q[j + 1] - Q[j] + P) % P;",
      "      Q[j] = Q[j] * x[i] % P;",
      "    }",
      "  }",
      "",
      "  for (int i = 0; i < N; i++) {",
      "    ll ainv = power(x[i], P - 2, P), c = 1;",
      "",
      "    for (int j = 0; j < N; j++)",
      "      if (i != j) c = c * (x[j] - x[i] + P) % P;",
      "",
      "    ll prev = Q[0], p = (ll)y[i] * power(c, P - 2, P) % P;",
      "    for (int j = 0; j < N; j++) {",
      "      ll v = x[i] ? prev * ainv % P : P - Q[j + 1]; //: Q[j+1] * inv(-1) % P;",
      "      res[j] = (v * p + res[j]) % P;",
      "      prev = (Q[j + 1] + v) % P;",
      "    }",
      "  }",
      "",
      "  return res;",
      "}",
      "",
      "// y[i] = f(x[i]) mod P",
      "// 0 <= y[i], T < P",
      "// res = f(T)",
      "int lagrangeInterpolation(const vector<int> &y, int T, int P) {",
      "  int N = y.size();",
      "  ll val = T, res = 0, fact = 1;",
      "",
      "  for (int i = 1; i < N; i++) {",
      "    fact = fact * i % P;",
      "    val = (val * (T - i + P)) % P;",
      "  }",
      "  fact = power(fact, P - 2, P);",
      "",
      "  for (int i = 0; i < N; i++) {",
      "    ll tmp = y[i] * val % P * power(T - i, P - 2, P) % P * fact % P;",
      "    fact = fact * (N - i - 1) % P * power(i + 1, P - 2, P) % P;",
      "    res += tmp * ((N - i) % 2 ? 1 : -1);",
      "  }",
      "",
      "  return (res % P + P) % P;",
      "}"
    ],
    "description": "Lagrange Interpolation"
  },
  "Chinese Remainder Theorem": {
    "prefix": "chinese",
    "body": [
      "/* \u4e2d\u56fd\u5270\u4f59\u5b9a\u7406 */",
      "",
      "pair<ll, ll> CRT(ll a1, ll m1, ll a2, ll m2) {",
      "  auto eg = ext_gcd(m1, m2);",
      "  ll d = eg.first;",
      "  if ((a2 - a1) % d) return {0, -1};",
      "  ll m = m1 / d * m2;",
      "  ll r = ((a1 + m1 * ((__int128_t)(a2 - a1) / d * eg.second.first % (m2 / d))) % m + m) % m;",
      "  return {r, m};",
      "}"
    ],
    "description": "Chinese Remainder Theorem"
  },
  "All the Subsets": {
    "prefix": "subsets",
    "body": [
      "// 0101 => {0101, 0100, 0001}",
      "for (int i = mask; i > 0; i = (i - 1) & mask) {}",
      "",
      "// 0101 => {0101, 0100, 0001, 0000}",
      "for (int i = mask;; i = (i - 1) & mask) {",
      "  //do something",
      "  if (i == 0) break;",
      "}",
      "",
      "// 0101 => {0101, 1101, 0111, 1111}",
      "for (int i = mask; i < (1 << n); i = (i + 1) | mask) {}"
    ],
    "description": "All the Subsets"
  },
  "Simple Segment Tree": {
    "prefix": "simpleseg",
    "body": [
      "/* SimpleSegTree(0-index) */",
      "",
      "template<typename Type = int>",
      "struct SimpleSegTree {",
      "  int segn2;",
      "  Type initVal;",
      "  vector<Type> data;",
      "",
      "  virtual Type merge(Type a, Type b) = 0;",
      "",
      "  SimpleSegTree(int n, Type initVal): initVal(initVal) {",
      "    for (segn2 = 1; segn2 < n; segn2 *= 2)",
      "      ;",
      "    data.assign(segn2 * 2, initVal);",
      "  }",
      "",
      "  Type query(int a, int b, int l = 0, int r = -1, int k = 0) {",
      "    if (r == -1) r = segn2;",
      "    if (a <= l && r <= b) return data[k];",
      "    if (r <= a || b <= l) return initVal;",
      "    return merge(query(a, b, l, (l + r) / 2, k * 2 + 1), query(a, b, (l + r) / 2, r, k * 2 + 2));",
      "  }",
      "",
      "  //set kth number x",
      "  void set(int k, Type x) {",
      "    k += segn2 - 1;",
      "    data[k] = x;",
      "    while (k > 0) {",
      "      k = (k - 1) / 2;",
      "      data[k] = merge(data[k * 2 + 1], data[k * 2 + 2]);",
      "    }",
      "  }",
      "};",
      "",
      "",
      "template<typename Type = int>",
      "struct RangeMinimumQuery final: SimpleSegTree<Type> {",
      "  RangeMinimumQuery(int n, Type initVal = INF): SimpleSegTree<Type>(n, initVal) {}",
      "  Type merge(Type a, Type b) {",
      "    return min(a, b);",
      "  }",
      "};",
      "",
      "template<typename Type = int>",
      "struct RangeMaximumQuery final: SimpleSegTree<Type> {",
      "  RangeMaximumQuery(int n, Type initVal = -INF): SimpleSegTree<Type>(n, initVal) {}",
      "  Type merge(Type a, Type b) {",
      "    return max(a, b);",
      "  }",
      "};",
      "",
      "template<typename Type = int>",
      "struct RangeSumQuery final: SimpleSegTree<Type> {",
      "  RangeSumQuery(int n, Type initVal = 0): SimpleSegTree<Type>(n, initVal) {}",
      "  Type merge(Type a, Type b) {",
      "    return a + b;",
      "  }",
      "};"
    ],
    "description": "Simple Segment Tree"
  },
  "SegmentTree(RangeSum,RangeAdd)": {
    "prefix": "segtree",
    "body": [
      "/* SegmentTree(Sum) */",
      "//0-index",
      "",
      "template<typename Type = int>",
      "struct SegTree {",
      "  int segn2;",
      "  Type inf;",
      "  vector<Type> data, s_data;",
      "",
      "  SegTree(int n) {",
      "    for (segn2 = 1; segn2 < n; segn2 *= 2)",
      "      ;",
      "",
      "    data.assign(segn2 * 2, 0);",
      "    s_data.assign(segn2 * 2, 0);",
      "  }",
      "",
      "  //get sum of [a, b)",
      "  Type query(int a, int b, int l = 0, int r = -1, int k = 0) {",
      "    if (r == -1) r = segn2;",
      "    if (r <= a || b <= l) return 0;",
      "    if (a <= l && r <= b) return data[k] + s_data[k] * (r - l);",
      "",
      "    return (min(r, b) - max(l, a)) * s_data[k] +",
      "           query(a, b, l, (l + r) / 2, k * 2 + 1) + query(a, b, (l + r) / 2, r, k * 2 + 2);",
      "  }",
      "",
      "  //add x to [a, b)",
      "  Type add(int a, int b, Type x, int l = 0, int r = -1, int k = 0) {",
      "    if (r == -1) r = segn2;",
      "",
      "    if (a <= l && r <= b)",
      "      s_data[k] += x;",
      "    else if (a < r && l < b)",
      "      data[k] = add(a, b, x, l, (l + r) / 2, k * 2 + 1) + add(a, b, x, (l + r) / 2, r, k * 2 + 2);",
      "",
      "    return data[k] + s_data[k] * (r - l);",
      "  }",
      "};"
    ],
    "description": "SegmentTree(RangeSum,RangeAdd)"
  },
  "Starry Sky Tree": {
    "prefix": "starrysky",
    "body": [
      "/* Starry Sky Tree */",
      "//0-index",
      "",
      "template<typename Type = int>",
      "struct StarrySkyTree {",
      "  int segn2;",
      "  Type errorVal;",
      "  vector<Type> data, s_data;",
      "",
      "  virtual Type merge(Type a, Type b) = 0;",
      "",
      "  StarrySkyTree(int n, Type errorVal): errorVal(errorVal) {",
      "    for (segn2 = 1; segn2 < n; segn2 *= 2)",
      "      ;",
      "    data.assign(segn2 * 2, 0);",
      "    s_data.assign(segn2 * 2, 0);",
      "  }",
      "",
      "  //get value of [a,b)",
      "  Type query(int a, int b, int l = 0, int r = -1, int k = 0) {",
      "    if (r == -1) r = segn2;",
      "    if (r <= a || b <= l) return errorVal;",
      "    if (a <= l && r <= b) return data[k] + s_data[k];",
      "    return merge(query(a, b, l, (l + r) / 2, k * 2 + 1), query(a, b, (l + r) / 2, r, k * 2 + 2)) + s_data[k];",
      "  }",
      "",
      "  //add x to [a,b)",
      "  Type add(int a, int b, Type x, int l = 0, int r = -1, int k = 0) {",
      "    if (r == -1) r = segn2;",
      "    if (a <= l && r <= b)",
      "      s_data[k] += x;",
      "    else if (a < r && l < b)",
      "      data[k] = merge(add(a, b, x, l, (l + r) / 2, k * 2 + 1), add(a, b, x, (l + r) / 2, r, k * 2 + 2));",
      "",
      "    return data[k] + s_data[k];",
      "  }",
      "};",
      "",
      "template<typename Type = int>",
      "struct StarrySkyTreeMax final: StarrySkyTree<Type> {",
      "  StarrySkyTreeMax(int n, Type errorVal = -INF): StarrySkyTree<Type>(n, errorVal) {}",
      "  Type merge(Type a, Type b) {",
      "    return max(a, b);",
      "  }",
      "};",
      "",
      "template<typename Type = int>",
      "struct StarrySkyTreeMin final: StarrySkyTree<Type> {",
      "  StarrySkyTreeMin(int n, Type errorVal = INF): StarrySkyTree<Type>(n, errorVal) {}",
      "  Type merge(Type a, Type b) {",
      "    return min(a, b);",
      "  }",
      "};"
    ],
    "description": "Starry Sky Tree"
  },
  "Dynamic RangeAdd SegmentTree": {
    "prefix": "dynamicseg",
    "body": [
      "template<typename T>",
      "struct DynamicRangeAddSegtree {",
      "  struct Node {",
      "    T val, add;",
      "    Node *l, *r;",
      "",
      "    Node(): val(0), add(0), l(NULL), r(NULL) {}",
      "    ~Node() {",
      "      if (l) delete l;",
      "      if (r) delete r;",
      "    }",
      "  };",
      "",
      "  Node root;",
      "  ll segn2;",
      "",
      "  DynamicRangeAddSegtree(ll n) {",
      "    for (segn2 = 1; segn2 < n; segn2 *= 2)",
      "      ;",
      "  }",
      "",
      "  virtual T merge(T a, T b) = 0;",
      "  virtual T rangeAdd(ll a, ll b, ll l, ll r, T add) = 0;",
      "",
      "  void add(ll a, ll b, T c) {",
      "    add(a, b, c, 0, segn2, &root);",
      "  }",
      "",
      "  T query(ll a, ll b) {",
      "    return query(a, b, 0, segn2, &root);",
      "  }",
      "",
      "private:",
      "  T add(ll a, ll b, T c, ll l, ll r, Node *node) {",
      "    if (!(r <= a || b <= l)) {",
      "      if (a <= l && r <= b) {",
      "        node->add += c;",
      "      } else {",
      "        if (node->l == NULL) node->l = new Node();",
      "        if (node->r == NULL) node->r = new Node();",
      "",
      "        T lVal = add(a, b, c, l, (l + r) / 2, node->l);",
      "        T rVal = add(a, b, c, (l + r) / 2, r, node->r);",
      "",
      "        node->val = merge(lVal, rVal);",
      "      }",
      "    }",
      "",
      "    return node->val + rangeAdd(l, r, l, r, node->add);",
      "  }",
      "",
      "  T query(ll a, ll b, ll l, ll r, Node *node) {",
      "    T res = 0;",
      "    if (r <= a || b <= l) return 0;",
      "",
      "    if (a <= l && r <= b)",
      "      return node->val + rangeAdd(a, b, l, r, node->add);",
      "",
      "    if (node->l) res = merge(res, query(a, b, l, (l + r) / 2, node->l));",
      "    if (node->r) res = merge(res, query(a, b, (l + r) / 2, r, node->r));",
      "",
      "    return res + rangeAdd(a, b, l, r, node->add);",
      "  }",
      "};",
      "",
      "template<typename T>",
      "struct DynamicRangeAddRangeSumSegtree final: DynamicRangeAddSegtree<T> {",
      "  using DynamicRangeAddSegtree<T>::DynamicRangeAddSegtree;",
      "  T merge(T a, T b) { return a + b; }",
      "  T rangeAdd(ll a, ll b, ll l, ll r, T add) { return max(0LL, min(r, b) - max(a, l)) * add; }",
      "};",
      "",
      "template<typename T>",
      "struct DynamicRangeAddRangeMinSegtree final: DynamicRangeAddSegtree<T> {",
      "  using DynamicRangeAddSegtree<T>::DynamicRangeAddSegtree;",
      "  T merge(T a, T b) { return min(a, b); }",
      "  T rangeAdd(ll a, ll b, ll l, ll r, T add) { return add; }",
      "};",
      "",
      "template<typename T>",
      "struct DynamicRangeAddRangeMaxSegtree final: DynamicRangeAddSegtree<T> {",
      "  using DynamicRangeAddSegtree<T>::DynamicRangeAddSegtree;",
      "  T merge(T a, T b) { return min(a, b); }",
      "  T rangeAdd(ll a, ll b, ll l, ll r, T add) { return add; }",
      "};"
    ],
    "description": "Dynamic RangeAdd SegmentTree"
  },
  "Binary Indexed Tree": {
    "prefix": "bit",
    "body": [
      "/* Binary Indexed Tree(0-index) */",
      "",
      "template<typename Type = int>",
      "struct BIT {",
      "  int bit_size;",
      "  vector<Type> data;",
      "",
      "  BIT(int n) {",
      "    bit_size = n;",
      "    data.assign(n + 2, 0);",
      "  }",
      "",
      "  //add x to kth value",
      "  void add(int k, Type x) {",
      "    k++;",
      "    while (k <= bit_size) {",
      "      data[k] += x;",
      "      k += k & (-k);",
      "    }",
      "  }",
      "",
      "  //sum of [0,k)",
      "  Type query(int k) {",
      "    Type rec = 0;",
      "    while (k > 0) {",
      "      rec += data[k];",
      "      k -= k & (-k);",
      "    }",
      "    return rec;",
      "  }",
      "",
      "  //sum of [a, b)",
      "  Type query(int a, int b) {",
      "    return query(b) - query(a);",
      "  }",
      "};"
    ],
    "description": "Binary Indexed Tree"
  },
  "Lazy Propagation Segment Tree(RangeSum)": {
    "prefix": "lazyseg",
    "body": [
      "/* LazyPropagationSegmentTree(Sum) */",
      "//0-index",
      "",
      "template<typename Type = int>",
      "struct LazySeg_sum {",
      "  struct Data {",
      "    Type val, add, sum;",
      "    bool valset;",
      "",
      "    Type calc_sum(int l, int r) {",
      "      if (valset) return (val + add) * (r - l);",
      "      return sum + add * (r - l);",
      "    }",
      "",
      "    void set_data(Type x, Type y) {",
      "      val = x;",
      "      add = y;",
      "      valset = true;",
      "    }",
      "",
      "    void add_data(Type x) {",
      "      add += x;",
      "    }",
      "",
      "    Data(): val(0), add(0), sum(0), valset(false) {}",
      "  };",
      "",
      "  vector<Data> data;",
      "  int seg_size;",
      "",
      "  LazySeg_sum(int n) {",
      "    for (seg_size = 1; seg_size < n; seg_size *= 2)",
      "      ;",
      "    data.assign(seg_size * 2, Data());",
      "  }",
      "",
      "  // set value to [a, b)",
      "  Type set(int a, int b, Type x, int l = 0, int r = -1, int k = 0) {",
      "    if (r == -1) r = seg_size;",
      "",
      "    if (a <= l && r <= b) {",
      "      data[k].set_data(x, 0);",
      "      return data[k].calc_sum(l, r);",
      "    }",
      "",
      "    if (r <= a || b <= l) return data[k].calc_sum(l, r);",
      "",
      "    if (data[k].valset) {",
      "      data[k * 2 + 1].set_data(data[k].val, data[k].add);",
      "      data[k * 2 + 2].set_data(data[k].val, data[k].add);",
      "    } else {",
      "      data[k * 2 + 1].add_data(data[k].add);",
      "      data[k * 2 + 2].add_data(data[k].add);",
      "    }",
      "",
      "    data[k].add = 0;",
      "    data[k].valset = false;",
      "    data[k].sum = set(a, b, x, l, (l + r) / 2, k * 2 + 1) + set(a, b, x, (l + r) / 2, r, k * 2 + 2);",
      "",
      "    return data[k].calc_sum(l, r);",
      "  }",
      "",
      "  // add to [a, b)",
      "  Type add(int a, int b, Type x, int l = 0, int r = -1, int k = 0) {",
      "    if (r == -1) r = seg_size;",
      "",
      "    if (a <= l && r <= b) {",
      "      data[k].add += x;",
      "      return data[k].calc_sum(l, r);",
      "    }",
      "",
      "    if (r <= a || b <= l) return data[k].calc_sum(l, r);",
      "",
      "    if (data[k].valset) {",
      "      data[k * 2 + 1].set_data(data[k].val, data[k].add);",
      "      data[k * 2 + 2].set_data(data[k].val, data[k].add);",
      "      data[k].add = 0;",
      "      data[k].valset = false;",
      "    }",
      "",
      "    data[k].sum = add(a, b, x, l, (l + r) / 2, k * 2 + 1) + add(a, b, x, (l + r) / 2, r, k * 2 + 2);",
      "",
      "    return data[k].calc_sum(l, r);",
      "  }",
      "",
      "  //get value of [a, b)",
      "  Type query(int a, int b, int l = 0, int r = -1, int k = 0) {",
      "    if (r == -1) r = seg_size;",
      "",
      "    if (r <= a || b <= l) return 0;",
      "",
      "    if ((a <= l && r <= b) || data[k].valset)",
      "      return data[k].calc_sum(max(a, l), min(b, r));",
      "",
      "    return query(a, b, l, (l + r) / 2, k * 2 + 1) + query(a, b, (l + r) / 2, r, k * 2 + 2) +",
      "           data[k].add * (min(b, r) - max(a, l));",
      "  }",
      "};"
    ],
    "description": "Lazy Propagation Segment Tree(RangeSum)"
  },
  "Range Tree": {
    "prefix": "rangetree",
    "body": [
      "/* RangeTree */",
      "",
      "template<typename T>",
      "struct RangeTree {",
      "  vector<vector<T>> dat;",
      "  int segn2, N;",
      "",
      "  RangeTree(int n, T *a): N(n) {",
      "    for (segn2 = 1; segn2 < n; segn2 *= 2)",
      "      ;",
      "    dat.assign(segn2 * 2, vector<T>());",
      "    init(a, 0, 0, n);",
      "  }",
      "",
      "  void init(T *a, int k, int l, int r) {",
      "    if (r - l == 1) {",
      "      dat[k].push_back(a[l]);",
      "    } else {",
      "      int lch = k * 2 + 1, rch = k * 2 + 2;",
      "      init(a, lch, l, (l + r) / 2);",
      "      init(a, rch, (l + r) / 2, r);",
      "      dat[k].resize(r - l);",
      "",
      "      merge(dat[lch].begin(), dat[lch].end(),",
      "        dat[rch].begin(), dat[rch].end(),",
      "        dat[k].begin());",
      "    }",
      "  }",
      "",
      "  //A[i:j-1] \u306e x\u4ee5\u4e0b\u306e\u500b\u6570",
      "  int query(int i, int j, T x, int l = 0, int r = -1, int k = 0) {",
      "    if (r == -1) r = N;",
      "",
      "    if (j <= l || r <= i) return 0;",
      "",
      "    if (i <= l && r <= j)",
      "      return upper_bound(dat[k].begin(), dat[k].end(), x) - dat[k].begin();",
      "",
      "    int lc = query(i, j, x, l, (l + r) / 2, k * 2 + 1);",
      "    int rc = query(i, j, x, (l + r) / 2, r, k * 2 + 2);",
      "    return lc + rc;",
      "  }",
      "};"
    ],
    "description": "Range Tree"
  },
  "Li Chao Tree": {
    "prefix": "lichao",
    "body": [
      "/* Li Chao Tree */",
      "",
      "template<typename T>",
      "struct LiChaoTree {",
      "  using Line = pair<T, T>; // first * x + second",
      "",
      "  int segn2;",
      "  vector<Line> data;",
      "  vector<T> X;",
      "",
      "  template<typename S>",
      "  LiChaoTree(vector<S> pos) {",
      "    int N = pos.size();",
      "    for (segn2 = 1; segn2 < N; segn2 *= 2)",
      "      ;",
      "    data.assign(segn2 * 2, {0, INF});",
      "    X.assign(segn2, INF);",
      "    for (int i = 0; i < (int)pos.size(); i++)",
      "      X[i] = pos[i];",
      "  }",
      "",
      "  inline T f(Line line, T x) {",
      "    return line.first * x + line.second;",
      "  }",
      "",
      "  void addLine(int a, int b, Line line, int l = 0, int r = -1, int k = 0) {",
      "    if (r == -1) r = segn2;",
      "    int m = (l + r) / 2;",
      "",
      "    if (r <= a || b <= l) return;",
      "    if (l < a || b < r) {",
      "      addLine(a, b, line, l, m, k * 2 + 1);",
      "      addLine(a, b, line, m, r, k * 2 + 2);",
      "      return;",
      "    }",
      "    if (data[k].second == INF) { //isNull",
      "      data[k] = line;",
      "      return;",
      "    }",
      "",
      "    bool fl = f(line, X[l]) < f(data[k], X[l]);",
      "    bool fm = f(line, X[m]) < f(data[k], X[m]);",
      "    bool fr = f(line, X[r - 1]) < f(data[k], X[r - 1]);",
      "",
      "    if (fl == fr) {",
      "      if (fl) data[k] = line;",
      "      return;",
      "    }",
      "    if (fm) swap(data[k], line);",
      "",
      "    if (fl ^ fm)",
      "      addLine(a, b, line, l, m, 2 * k + 1);",
      "    else",
      "      addLine(a, b, line, m, r, 2 * k + 2);",
      "  }",
      "",
      "  void addLine(Line line) { addLine(0, segn2, line); }",
      "",
      "  T query(int k) {",
      "    T x = X[k], res = LLINF;",
      "    k += segn2 - 1;",
      "",
      "    while (1) {",
      "      if (data[k].second != INF) //isNotNull",
      "        res = min(res, f(data[k], x));",
      "      if (!k) break;",
      "      k = (k - 1) / 2;",
      "    }",
      "",
      "    return res;",
      "  }",
      "};"
    ],
    "description": "Li Chao Tree"
  },
  "UnionFind": {
    "prefix": "unionfind",
    "body": [
      "/* UnionFind */",
      "",
      "struct UnionFind {",
      "  vector<int> data;",
      "  UnionFind(int s): data(s, -1) {}",
      "",
      "  int root(int x) {",
      "    if (data[x] < 0) return x;",
      "    return data[x] = root(data[x]);",
      "  }",
      "",
      "  bool set(int x, int y) {",
      "    x = root(x);",
      "    y = root(y);",
      "    if (x == y) return false;",
      "    if (data[x] > data[y]) swap(x, y);",
      "    data[x] += data[y];",
      "    data[y] = x;",
      "    return true;",
      "  }",
      "",
      "  bool check(int x, int y) {",
      "    return root(x) == root(y);",
      "  }",
      "",
      "  int size(int x) {",
      "    return -data[root(x)];",
      "  }",
      "};"
    ],
    "description": "UnionFind"
  },
  "Lowest Common Ancestor": {
    "prefix": "lca",
    "body": [
      "/*Lowest Common Ancstor*/",
      "struct LCA {",
      "  int n;",
      "  vector<vector<int>> tree, parent;",
      "  vector<int> depth;",
      "  int log2n;",
      "",
      "  LCA(int n): n(n), tree(n), depth(n, -1) {",
      "    log2n = 0;",
      "    for (log2n = 1; (1 << log2n) < n; log2n++)",
      "      ;",
      "    parent.assign(log2n, vector<int>(n, -1));",
      "  }",
      "",
      "  void add_edge(int u, int v) {",
      "    tree[u].push_back(v);",
      "    tree[v].push_back(u);",
      "  }",
      "",
      "  void dfs(int now, int p, int d) {",
      "    parent[0][now] = p;",
      "    depth[now] = d;",
      "",
      "    for (int to : tree[now])",
      "      if (to != p)",
      "        dfs(to, now, d + 1);",
      "  }",
      "",
      "  void build(int root) {",
      "    dfs(root, -1, 0);",
      "",
      "    for (int i = 0; i < log2n - 1; i++)",
      "      for (int j = 0; j < n; j++)",
      "        parent[i + 1][j] = parent[i][j] == -1 ? -1 : parent[i][parent[i][j]];",
      "  }",
      "",
      "  int query(int a, int b) {",
      "    if (depth[a] > depth[b]) swap(a, b);",
      "",
      "    for (int i = 0; i < log2n; i++)",
      "      if ((depth[b] - depth[a]) >> i & 1)",
      "        b = parent[i][b];",
      "",
      "    if (a == b) return a;",
      "",
      "    for (int i = log2n - 1; i >= 0; i--) {",
      "      if (parent[i][a] != parent[i][b]) {",
      "        a = parent[i][a];",
      "        b = parent[i][b];",
      "      }",
      "    }",
      "",
      "    return parent[0][a];",
      "  }",
      "};"
    ],
    "description": "Lowest Common Ancestor"
  },
  "Centroid Decomposition": {
    "prefix": "centroid",
    "body": [
      "/* \u91cd\u5fc3\u5206\u89e3 */",
      "",
      "struct CentroidDecomposition {",
      "  int n;",
      "  vector<vector<int>> G;",
      "  vector<int> sub, used;",
      "",
      "  CentroidDecomposition(int n): n(n), G(n, vector<int>()), sub(n, 0), used(n, 0) {}",
      "",
      "  void addEdge(int u, int v) {",
      "    G[u].push_back(v);",
      "    G[v].push_back(u);",
      "  }",
      "",
      "  int build(int now, int prev) {",
      "    sub[now] = 1;",
      "    for (auto to : G[now]) {",
      "      if (to != prev && !used[to])",
      "        sub[now] += build(to, now);",
      "    }",
      "    return sub[now];",
      "  }",
      "",
      "  int searchCentroid(int now, int prev, int mid) {",
      "    for (auto to : G[now]) {",
      "      if (to == prev || used[to]) continue;",
      "      if (sub[to] > mid) return searchCentroid(to, now, mid);",
      "    }",
      "    return now;",
      "  }",
      "",
      "  int solve(int now, const function<void(int, vector<int> &)> &func) {",
      "    vector<int> children;",
      "    int centroid = searchCentroid(now, -1, build(now, -1) / 2);",
      "    //func(centroid, children); //before",
      "    used[centroid] = true;",
      "    for (auto to : G[centroid])",
      "      if (!used[to])",
      "        children.push_back(solve(to, func));",
      "    func(centroid, children); //after",
      "    return centroid;",
      "  }",
      "};",
      "",
      "// auto func = [&](int centroid, vector<int> &vec){}"
    ],
    "description": "Centroid Decomposition"
  },
  "Dijkstra": {
    "prefix": "dijkstra",
    "body": [
      "/* Dijkstra O(NlogM)*/",
      "",
      "template<typename Type = int>",
      "struct Dijkstra {",
      "  int V;",
      "  vector<vector<pair<int, Type>>> G;",
      "  vector<Type> cost;",
      "",
      "  Dijkstra(int n): V(n), G(n, vector<pair<int, Type>>()) {}",
      "",
      "  void add_edge(int u, int v, Type c) {",
      "    G[u].push_back({v, c});",
      "  }",
      "",
      "  Type solve(int s, int g = -1) {",
      "    cost.assign(V, -1);",
      "    priority_queue<pair<Type, int>> pq;",
      "    Type max_cost = 0;",
      "",
      "    pq.push({0, s});",
      "",
      "    while (pq.size()) {",
      "      Type now_cost = pq.top().first;",
      "      int now = pq.top().second;",
      "      pq.pop();",
      "",
      "      if (cost[now] >= 0) continue;",
      "",
      "      cost[now] = -now_cost;",
      "      max_cost = max(max_cost, -now_cost);",
      "",
      "      if (now == g) return -now_cost;",
      "",
      "      for (int i = 0; i < (int)G[now].size(); i++)",
      "        pq.push({now_cost - G[now][i].second, G[now][i].first});",
      "    }",
      "",
      "    return max_cost;",
      "  }",
      "};"
    ],
    "description": "Dijkstra"
  },
  "Topological Sort": {
    "prefix": "tsort",
    "body": [
      "/* TopologicalSort */",
      "",
      "vector<int> TopologicalSort(const vector<vector<int>> &G, int n = -1) {",
      "  if (n == -1) n = (int)G.size();",
      "",
      "  queue<int> que;",
      "  vector<int> res, indeg(n + 1, 0);",
      "",
      "  for (int i = 0; i < n; i++)",
      "    for (int v : G[i])",
      "      indeg[v]++;",
      "",
      "  for (int i = 0; i < n; i++)",
      "    if (indeg[i] == 0)",
      "      que.push(i);",
      "",
      "  while (que.size()) {",
      "    int u = que.front();",
      "    que.pop();",
      "",
      "    res.push_back(u);",
      "",
      "    for (int v : G[u]) {",
      "      indeg[v]--;",
      "      if (indeg[v] == 0) que.push(v);",
      "    }",
      "  }",
      "",
      "  return n == (int)res.size() ? res : vector<int>();",
      "}"
    ],
    "description": "Topological Sort"
  },
  "Bridges \\& 2-edge-connected Components": {
    "prefix": "bridges",
    "body": [
      "/* Bridges & 2-edge-connected Components */",
      "",
      "struct Bridges {",
      "  vector<pair<int, int>> edges;",
      "  vector<vector<pair<int, int>>> G;",
      "",
      "  vector<int> cmp, isBridge; //\u5727\u7e2e\u5f8c\u306b\u5c5e\u3059\u308bComponent\u756a\u53f7, \u6a4b\u3067\u3042\u308b\u304b",
      "  vector<pair<int, int>> cmpEdges; //\u5727\u7e2e\u5f8c\u306eedge",
      "",
      "  int idx, cmpIdx;",
      "  vector<int> ord, inSt;",
      "  stack<int> roots, st;",
      "",
      "  Bridges(int N): G(N, vector<pair<int, int>>()), cmp(N), idx(0), cmpIdx(0), ord(N, -1), inSt(N, 0) {}",
      "",
      "  void add_edge(int u, int v) {",
      "    G[u].push_back({v, edges.size()});",
      "    G[v].push_back({u, edges.size()});",
      "    edges.push_back({u, v});",
      "    isBridge.push_back(false);",
      "  }",
      "",
      "  void dfs(int now, int eid = -1) {",
      "    ord[now] = idx++;",
      "    roots.push(now);",
      "    st.push(now);",
      "    inSt[now] = true;",
      "",
      "    for (auto e : G[now]) {",
      "      int to = e.first;",
      "      if (ord[to] == -1)",
      "        dfs(to, e.second);",
      "      else if (eid != e.second && inSt[to])",
      "        while (ord[roots.top()] > ord[to]) roots.pop();",
      "    }",
      "    if (now == roots.top()) {",
      "      while (1) {",
      "        int w = st.top();",
      "        st.pop();",
      "        inSt[w] = false;",
      "        cmp[w] = cmpIdx;",
      "        if (now == w) break;",
      "      }",
      "      if (eid != -1) isBridge[eid] = true;",
      "      roots.pop();",
      "      cmpIdx++;",
      "    }",
      "  }",
      "",
      "  void build() {",
      "    for (int i = 0; i < (int)ord.size(); i++)",
      "      if (ord[i] == -1)",
      "        dfs(i);",
      "",
      "    for (int i = 0; i < (int)edges.size(); i++) {",
      "      if (isBridge[i])",
      "        cmpEdges.push_back({cmp[edges[i].first], cmp[edges[i].second]});",
      "    }",
      "  }",
      "};"
    ],
    "description": "Bridges \\& 2-edge-connected Components"
  },
  "Bipartite Matching": {
    "prefix": "2match",
    "body": [
      "/* Bipartite Matching */",
      "",
      "struct BipartiteMatching {",
      "  int V;",
      "  vector<vector<int>> G;",
      "  vector<int> match;",
      "  vector<bool> used;",
      "",
      "  BipartiteMatching(int n): V(n), G(n) {}",
      "",
      "  void add_edge(int u, int v) {",
      "    G[u].push_back(v);",
      "    G[v].push_back(u);",
      "  }",
      "",
      "  bool dfs(int v) {",
      "    used[v] = true;",
      "    for (int u : G[v]) {",
      "      int w = match[u];",
      "      if (w < 0 || (!used[w] && dfs(w))) {",
      "        match[v] = u;",
      "        match[u] = v;",
      "        return true;",
      "      }",
      "    }",
      "    return false;",
      "  }",
      "",
      "  int solve() {",
      "    int res = 0;",
      "    match.assign(V, -1);",
      "    for (int i = 0; i < V; i++) {",
      "      if (match[i] < 0) {",
      "        used.assign(V, false);",
      "        if (dfs(i)) res++;",
      "      }",
      "    }",
      "    return res;",
      "  }",
      "};"
    ],
    "description": "Bipartite Matching"
  },
  "Maximum Matching": {
    "prefix": "maxmatch",
    "body": [
      "/* \u6700\u5927\u30de\u30c3\u30c1\u30f3\u30b0 */",
      "// https://qiita.com/Kutimoti_T/items/5b579773e0a24d650bdf",
      "",
      "struct MaximumMatching {",
      "  int N;",
      "  vector<vector<pair<int, int>>> G;",
      "  vector<pair<int, int>> edges;",
      "  vector<int> first, mate, label;",
      "  queue<int> que;",
      "",
      "  MaxMatching(int N): N(N), G(N + 1), first(N + 1), mate(N + 1), label(N + 1, -1) {}",
      "",
      "  void add_edge(int a, int b) {",
      "    int id = edges.size() + N + 1;",
      "    a++;",
      "    b++;",
      "    G[a].push_back({b, id});",
      "    G[b].push_back({a, id});",
      "    edges.push_back({a, b});",
      "  }",
      "",
      "  void rematch(int u, int v) {",
      "    int t = mate[u], s = label[u];",
      "    mate[u] = v;",
      "    if (mate[t] != u) return;",
      "    if (s <= N) {",
      "      mate[t] = s;",
      "      rematch(s, t);",
      "    } else {",
      "      int x = edges[s - N - 1].first;",
      "      int y = edges[s - N - 1].second;",
      "      rematch(x, y);",
      "      rematch(y, x);",
      "    }",
      "  }",
      "",
      "  int evalFirst(int x) {",
      "    int &t = first[x];",
      "    if (label[t] < 0) return t;",
      "    return t = evalFirst(t);",
      "  }",
      "",
      "  void assignLabel(int x, int y, int num) {",
      "    int r = evalFirst(x), s = evalFirst(y);",
      "    int join = 0;",
      "    if (r == s) return;",
      "",
      "    label[r] = label[s] = -num;",
      "",
      "    while (1) {",
      "      if (s != 0) swap(r, s);",
      "      r = evalFirst(label[mate[r]]);",
      "      if (label[r] == -num) {",
      "        join = r;",
      "        break;",
      "      }",
      "      label[r] = -num;",
      "    }",
      "",
      "    for (int t : {x, y}) {",
      "      int v = first[t];",
      "      while (v != join) {",
      "        que.push(v);",
      "        label[v] = num;",
      "        first[v] = join;",
      "        v = first[label[mate[v]]];",
      "      }",
      "    }",
      "  }",
      "",
      "  bool augmentCheck(int u) {",
      "    first[u] = label[u] = 0;",
      "    que.push(u);",
      "",
      "    while (que.size()) {",
      "      int x = que.front();",
      "      que.pop();",
      "      for (auto e : G[x]) {",
      "        int y = e.first, &p = mate[y];",
      "        if (p == 0 && y != u) {",
      "          p = x;",
      "          rematch(x, y);",
      "          return true;",
      "        } else if (label[y] >= 0) {",
      "          assignLabel(x, y, e.second);",
      "        } else if (label[p] < 0) {",
      "          label[p] = x;",
      "          first[p] = y;",
      "          que.push(p);",
      "        }",
      "      }",
      "    }",
      "    return false;",
      "  }",
      "",
      "  vector<pair<int, int>> solve() {",
      "    for (int i = 1; i <= N; i++) {",
      "      que = queue<int>();",
      "      if (mate[i] != 0) continue;",
      "      if (augmentCheck(i))",
      "        fill(label.begin(), label.end(), -1);",
      "    }",
      "",
      "    vector<pair<int, int>> ans;",
      "    for (int i = 1; i <= N; i++)",
      "      if (i < mate[i]) ans.push_back({i - 1, mate[i] - 1});",
      "",
      "    return ans;",
      "  }",
      "};"
    ],
    "description": "Maximum Matching"
  },
  "Maximum Flow (Dinic)": {
    "prefix": "dinic",
    "body": [
      "/* Maximum flow (Dinic) */",
      "",
      "struct Dinic {",
      "  struct edge {",
      "    int to, cap, rev;",
      "    edge(int a, int b, int c): to(a), cap(b), rev(c) {}",
      "  };",
      "",
      "  vector<vector<edge>> G;",
      "  vector<int> level, iter;",
      "  int MAX_V;",
      "",
      "  Dinic(int max_v): G(max_v), MAX_V(max_v) {}",
      "",
      "  int add_edge(int from, int to, int cap) {",
      "    int id = G[from].size();",
      "",
      "    G[from].push_back(edge(to, cap, G[to].size()));",
      "    G[to].push_back(edge(from, 0, G[from].size() - 1));",
      "",
      "    return id;",
      "  }",
      "",
      "  void bfs(int s) {",
      "    queue<int> q;",
      "    level.assign(MAX_V, -1);",
      "    level[s] = 0;",
      "    q.push(s);",
      "    while (q.size()) {",
      "      int v = q.front();",
      "      q.pop();",
      "      for (edge e : G[v]) {",
      "        if (e.cap > 0 && level[e.to] < 0) {",
      "          level[e.to] = level[v] + 1;",
      "          q.push(e.to);",
      "        }",
      "      }",
      "    }",
      "  }",
      "",
      "  int dfs(int v, int t, int f) {",
      "    if (v == t) return f;",
      "    for (int &i = iter[v]; i < (int)G[v].size(); i++) {",
      "      edge &e = G[v][i];",
      "      if (e.cap > 0 && level[v] < level[e.to]) {",
      "        int d = dfs(e.to, t, min(f, e.cap));",
      "        if (d > 0) {",
      "          e.cap -= d;",
      "          G[e.to][e.rev].cap += d;",
      "          return d;",
      "        }",
      "      }",
      "    }",
      "    return 0;",
      "  }",
      "",
      "  int solve(int s, int t) {",
      "    int flow = 0, f;",
      "    while (1) {",
      "      bfs(s);",
      "      if (level[t] < 0) return flow;",
      "      iter.assign(MAX_V, 0);",
      "      while ((f = dfs(s, t, INF)) > 0) flow += f;",
      "    }",
      "  }",
      "};"
    ],
    "description": "Maximum Flow (Dinic)"
  },
  "Minimum Cost Flow": {
    "prefix": "mincostflow",
    "body": [
      "/* Minimum Cost Flow */",
      "",
      "template<typename Type = int, Type inf = INF>",
      "struct MinimumCostFlow {",
      "  typedef pair<Type, int> P;",
      "",
      "  struct edge {",
      "    int to, cap, rev;",
      "    Type cost;",
      "    edge(int a, int b, int c, Type d): to(a), cap(b), rev(c), cost(d) {}",
      "  };",
      "",
      "  vector<vector<edge>> G;",
      "  vector<int> prevv, preve;",
      "  vector<Type> h, dist;",
      "  int V;",
      "",
      "  MinimumCostFlow(int v): G(v, vector<edge>()), prevv(v, 0), preve(v, 0), V(v) {}",
      "",
      "  int add_edge(int from, int to, int cap, Type cost) {",
      "    int id = G[from].size();",
      "",
      "    G[from].push_back(edge(to, cap, G[to].size(), cost));",
      "    G[to].push_back(edge(from, 0, G[from].size() - 1, -cost));",
      "",
      "    return id;",
      "  }",
      "",
      "  Type solve(int s, int t, int f) {",
      "    Type res = 0;",
      "    h.assign(V, 0);",
      "    while (f > 0) {",
      "      priority_queue<P, vector<P>, greater<P>> pq;",
      "      dist.assign(V, inf);",
      "      dist[s] = 0;",
      "      pq.push(P(0, s));",
      "      while (pq.size()) {",
      "        P p = pq.top();",
      "        pq.pop();",
      "        int v = p.second;",
      "        if (dist[v] < p.first) continue;",
      "",
      "        for (int i = 0; i < (int)G[v].size(); i++) {",
      "          edge &e = G[v][i];",
      "          Type d = dist[v] + e.cost + h[v] - h[e.to];",
      "          if (e.cap > 0 && dist[e.to] > d) {",
      "            dist[e.to] = d;",
      "            prevv[e.to] = v;",
      "            preve[e.to] = i;",
      "            pq.push(P(dist[e.to], e.to));",
      "          }",
      "        }",
      "      }",
      "      if (dist[t] == inf) return -1;",
      "",
      "      for (int v = 0; v < V; v++) h[v] += dist[v];",
      "",
      "      int d = f;",
      "      for (int v = t; v != s; v = prevv[v])",
      "        d = min(d, G[prevv[v]][preve[v]].cap);",
      "",
      "      f -= d;",
      "      res += d * h[t];",
      "",
      "      for (int v = t; v != s; v = prevv[v]) {",
      "        edge &e = G[prevv[v]][preve[v]];",
      "        e.cap -= d;",
      "        G[v][e.rev].cap += d;",
      "      }",
      "    }",
      "",
      "    return res;",
      "  }",
      "};"
    ],
    "description": "Minimum Cost Flow"
  },
  "Strongly Connected Component": {
    "prefix": "scc",
    "body": [
      "/* Strongly Connected Component */",
      "",
      "/*",
      " 1. dfs\u3092\u3057\u3066\u3001\u623b\u308b\u3068\u304d\u306b1\u304b\u3089\u9806\u306b\u756a\u53f7\u3092\u4ed8\u3051\u308b",
      " 2. \u6570\u5024\u304c\u5927\u304d\u3044\u30ce\u30fc\u30c9\u304b\u3089\u9006\u8fba\u3092\u4f7f\u3063\u3066dfs\u3092\u3059\u308b\u3002",
      "    \u3059\u3067\u306b\u8a2a\u308c\u3066\u3044\u308b\u30ce\u30fc\u30c9\u306b\u306f\u884c\u304b\u306a\u3044\u3002",
      "    \u305f\u3069\u308a\u7740\u3051\u308b\u30ce\u30fc\u30c9\u304c\u540c\u3058\u9023\u7d50\u6210\u5206\u306b\u5c5e\u3059\u308b\u3002",
      " */",
      "",
      "struct SCC {",
      "  int n;",
      "  vector<vector<int>> G, rG;",
      "  vector<int> vs, cmp;",
      "  vector<bool> used;",
      "",
      "  SCC(int n): n(n), G(n), rG(n), cmp(n) {}",
      "",
      "  void add_edge(int from, int to) {",
      "    G[from].push_back(to);",
      "    rG[to].push_back(from);",
      "  }",
      "",
      "  void dfs(int v) {",
      "    used[v] = true;",
      "    for (int to : G[v])",
      "      if (!used[to]) dfs(to);",
      "    vs.push_back(v);",
      "  }",
      "",
      "  void rdfs(int v, int k) {",
      "    used[v] = true;",
      "    cmp[v] = k;",
      "    for (int to : rG[v])",
      "      if (!used[to]) rdfs(to, k);",
      "  }",
      "",
      "  int solve() {",
      "    used.assign(n, false);",
      "    vs.clear();",
      "    for (int i = 0; i < n; i++)",
      "      if (!used[i]) dfs(i);",
      "    used.assign(n, false);",
      "    int k = 0;",
      "    for (int i = (int)vs.size() - 1; i >= 0; i--)",
      "      if (!used[vs[i]]) rdfs(vs[i], k++);",
      "    return k; //\u5f37\u9023\u7d50\u6210\u5206\u6570",
      "  }",
      "",
      "  //\u5c5e\u3059\u308b\u5f37\u9023\u7d50\u6210\u5206\u756a\u53f7(\u30c8\u30dd\u30ed\u30b8\u30ab\u30eb\u9806)",
      "  int operator[](int k) const {",
      "    return cmp[k];",
      "  }",
      "};"
    ],
    "description": "Strongly Connected Component"
  },
  "2-SAT": {
    "prefix": "2sat",
    "body": [
      "/* 2-SAT (Source: \u87fb\u672c)*/",
      "",
      "struct TwoSAT {",
      "  int n;",
      "  SCC scc;",
      "  vector<bool> ans;",
      "",
      "  TwoSAT(int n): n(n), scc(n * 2), ans(n) {}",
      "",
      "  //1-index, add(1, -2) -> p or not q",
      "  void add(int a, int b) {",
      "    a = a > 0 ? a - 1 : n - a - 1;",
      "    b = b > 0 ? b - 1 : n - b - 1;",
      "    scc.add_edge((a + n) % (2 * n), b);",
      "    scc.add_edge((b + n) % (2 * n), a);",
      "  }",
      "",
      "  bool solve() {",
      "    scc.solve();",
      "    for (int i = 0; i < n; i++)",
      "      if (scc.cmp[i] == scc.cmp[n + i]) return false;",
      "",
      "    for (int i = 0; i < n; i++)",
      "      ans[i] = scc.cmp[i] > scc.cmp[n + i];",
      "    return true;",
      "  }",
      "};"
    ],
    "description": "2-SAT"
  },
  "Geometry Template": {
    "prefix": "geotemp",
    "body": [
      "typedef double P_type; //\u5ea7\u6a19(integer or real)",
      "typedef double G_real; //\u5b9f\u6570\u306e\u623b\u308a\u5024(float or double or long double)",
      "typedef complex<P_type> P;",
      "const G_real P_eps = 1e-8; //\u6574\u6570\u306e\u6642\u306f\u30bc\u30ed",
      "",
      "namespace std {",
      "  template<class T>",
      "  bool operator<(const complex<T> &a, const complex<T> &b) {",
      "    return abs(a.real() - b.real()) < P_eps ? a.imag() + P_eps < b.imag() : a.real() + P_eps < b.real();",
      "  }",
      "};",
      "",
      "P rotate(P p, double theta) {",
      "  return p * P(cos(theta), sin(theta));",
      "}",
      "",
      "//\u5185\u7a4d",
      "P_type dot(P a, P b) {",
      "  return (a * conj(b)).real();",
      "}",
      "",
      "//\u5916\u7a4d",
      "P_type cross(P a, P b) {",
      "  return (conj(a) * b).imag();",
      "}",
      "",
      "//\u53cd\u6642\u8a08\u56de\u308a",
      "int ccw(P a, P b, P c) {",
      "  if (cross(b - a, c - a) > P_eps) return 1; //COUNTER_CLOCKWISE(center:a)",
      "  if (cross(b - a, c - a) < -P_eps) return -1; //CLOCKWISE(center:a)",
      "  if (dot(b - a, c - a) < -P_eps) return -2; //c -> a -> b",
      "  if (dot(a - b, c - b) < -P_eps) return 2; //a -> b -> c",
      "  return 0; //a -> c -> b",
      "}",
      "",
      "/*",
      "// \u504f\u89d2 [-pi, pi]",
      "// complex<int|ll> \u4f7f\u7528\u6642\u306e std::arg \u306e\u4ee3\u308f\u308a",
      "G_real arg(P p) {",
      "  return atan2(imag(p), real(p));",
      "}",
      "*/"
    ],
    "description": "Geometry Template"
  },
  "Geometry Library": {
    "prefix": "geolib",
    "body": [
      "/* \u30d9\u30af\u30c8\u30eba, b\u306e\u89d2\u5ea6 */",
      "// ({0, 1}, {1, 0}) => 90, ({0, 1}, {-1, -1}) => -135",
      "G_real degree(P a, P b) {",
      "  return atan2(cross(b, a), dot(b, a)) / M_PI * 180;",
      "}",
      "",
      "/* \u7dda\u5206ab\u3068\u70b9c\u306e\u8ddd\u96e2 */",
      "G_real distanceSP(P a, P b, P c) {",
      "  if (dot(b - a, c - a) < P_eps) return abs(c - a);",
      "  if (dot(a - b, c - b) < P_eps) return abs(c - b);",
      "  return abs(cross(b - a, c - a)) / abs(b - a);",
      "}",
      "",
      "/* \u76f4\u7ddaab\u3068\u70b9c\u306e\u8ddd\u96e2 */",
      "G_real distanceLP(P a, P b, P c) {",
      "  return abs(cross(b - a, c - a)) / abs(b - a);",
      "}",
      "",
      "/* \u5186\u306e\u70b9\u5305\u542b\u5224\u5b9a */",
      "bool isContainedCP(P c, P_type r, P p) {",
      "  return abs(c - p) < r - P_eps; //\u5186\u5468\u4e0a\u3092\u542b\u307e\u306a\u3044",
      "  //return abs(c-p) <= r + P_eps; //\u5186\u5468\u4e0a\u3092\u542b\u3080",
      "}",
      "",
      "/* \u5186\u306e\u5186\u5305\u542b\u5224\u5b9a (\u51861\u306e\u5185\u90e8\u306b\u51862\u304c\u5b58\u5728\u3059\u308b\u304b) */",
      "bool isContainedCC(P c1, P_type r1, P c2, P_type r2) {",
      "  return abs(c1 - c2) + r2 < r1 - P_eps; //\u63a5\u3059\u308b\u5834\u5408\u3092\u542b\u307e\u306a\u3044",
      "  //return abs(c1 - c2) + r2 <= r1 + P_eps; //\u63a5\u3059\u308b\u5834\u5408\u3092\u542b\u307e\u306a\u3044",
      "}",
      "",
      "/* \u76f4\u7dda\u4ea4\u5dee\u5224\u5b9a */",
      "bool isIntersectedLL(P a1, P a2, P b1, P b2) {",
      "  return abs(cross(a1 - a2, b1 - b2)) > P_eps;",
      "}",
      "",
      "/* \u7dda\u5206\u4ea4\u5dee\u5224\u5b9a */",
      "bool isIntersectedSS(P a1, P a2, P b1, P b2) {",
      "  //\u7dda\u5206a \u3068 \u76f4\u7ddab",
      "  int a = ccw(b1, b2, a1);",
      "  int b = ccw(b1, b2, a2);",
      "",
      "  //\u7dda\u5206b \u3068 \u76f4\u7ddaa",
      "  int c = ccw(a1, a2, b1);",
      "  int d = ccw(a1, a2, b2);",
      "",
      "  return a * b <= 0 && c * d <= 0; // T\u5b57\u3092\u9664\u304f\u6642\u306f (** < 0)",
      "}",
      "",
      "/* \u76f4\u7ddaA\u7dda\u5206B\u4ea4\u5dee\u5224\u5b9a */",
      "bool isIntersectedLS(P a1, P a2, P b1, P b2) {",
      "  int a = ccw(a1, a2, b1);",
      "  int b = ccw(a1, a2, b2);",
      "",
      "  // \u76f4\u7dda\u4e0a\u306e\u3068\u304d a or b = 0 or -2 or 2",
      "  return (a % 2) * (b % 2) <= 0; // T\u5b57\u3092\u9664\u304f\u6642\u306f (** < 0)",
      "}",
      "",
      "/* \u5186\u4ea4\u5dee\u5224\u5b9a */",
      "bool isIntersectedCC(P c1, G_real r1, P c2, P_type r2) {",
      "  G_real dist = abs(c1 - c2);",
      "",
      "  return abs(r1 - r2) <= dist + P_eps && dist - P_eps <= r1 + r2; //\u5916\u63a5\u5185\u63a5\u3092\u542b\u3080",
      "  //return abs(r1 - r2) < dist - P_eps && dist + P_eps < r1 + r2; //\u5916\u63a5\u5185\u63a5\u3092\u9664\u304f",
      "}",
      "",
      "/* \u5186\u76f4\u7dda\u4ea4\u5dee\u5224\u5b9a */",
      "bool isIntersectedCL(P c, G_real r, P a1, P a2) {",
      "  return distanceLP(a1, a2, c) <= r + P_eps; //\u63a5\u3059\u308b\u5834\u5408\u3092\u542b\u307e\u306a\u3044\u5834\u5408 < r - P_eps",
      "}",
      "",
      "/* \u5186\u7dda\u5206\u4ea4\u5dee\u5224\u5b9a */",
      "bool isIntersectedCS(P c, P_type r, P a1, P a2) {",
      "  return (!isContainedCP(c, r, a1) || !isContainedCP(c, r, a2)) &&",
      "         distanceLP(a1, a2, c) <= r + P_eps; //\u63a5\u3059\u308b\u5834\u5408\u3092\u542b\u307e\u306a\u3044\u5834\u5408 < r - P_eps",
      "}",
      "",
      "/* \u76f4\u7dda/\u7dda\u5206\u4ea4\u70b9 */",
      "vector<P> getCrosspointLL(P a1, P a2, P b1, P b2) {",
      "  if (!isIntersectedLL(a1, a2, b1, b2)) return {};",
      "",
      "  P a = a2 - a1;",
      "  P b = b2 - b1;",
      "  return {a1 + a * cross(b, b1 - a1) / cross(b, a)};",
      "}",
      "",
      "vector<P> getCrosspointSS(P a1, P a2, P b1, P b2) {",
      "  if (!isIntersectedSS(a1, a2, b1, b2)) return {};",
      "  return getCrosspointLL(a1, a2, b1, b2);",
      "}",
      "",
      "/* \u5186\u4ea4\u70b9 */",
      "vector<P> getCrosspointCC(P c1, P_type r1, P c2, P_type r2) {",
      "  if (!isIntersectedCC(c1, r1, c2, r2)) return {};",
      "",
      "  P_type dist = abs(c1 - c2);",
      "  P_type a = acos((r1 * r1 + dist * dist - r2 * r2) / (2 * r1 * dist));",
      "  return {c1 + polar(r1, arg(c2 - c1) + a), c1 + polar(r1, arg(c2 - c1) - a)};",
      "}",
      "",
      "/* \u5186\u76f4\u7dda\u4ea4\u70b9 */",
      "vector<P> getCrosspointCL(P c, P_type r, P a1, P a2) {",
      "  if (!isIntersectedCL(c, r, a1, a2)) return {};",
      "",
      "  P base1 = a2 - a1;",
      "  P proj = a1 + base1 * dot(c - a1, base1) / norm(base1); //\u5c04\u5f71",
      "  P e = (a2 - a1) / abs(a2 - a1);",
      "  P base2 = sqrt(r * r - norm(proj - c));",
      "  return {proj - e * base2, proj + e * base2};",
      "}",
      "",
      "/* \u5186\u7dda\u5206\u4ea4\u70b9 */",
      "vector<P> getCrosspointCS(P c, P_type r, P a1, P a2) {",
      "  if (!isIntersectedCS(c, r, a1, a2)) return {};",
      "",
      "  vector<P> res;",
      "  for (P p : getCrosspointCL(c, r, a1, a2))",
      "    if (dot(a1 - p, a2 - p) <= P_eps) res.push_back(p);",
      "  return res;",
      "}",
      "",
      "/* \u591a\u89d2\u5f62-\u70b9\u5305\u542b */",
      "bool isContainedPolyP(vector<P> &g, P p) {",
      "  int n = g.size();",
      "  bool f = false;",
      "  for (int i = 0; i < n; i++) {",
      "    P a = g[i] - p, b = g[(i + 1) % n] - p;",
      "    if (abs(cross(a, b)) < P_eps && dot(a, b) < P_eps) return true; //\u8fba\u4e0a",
      "    if (a.imag() > b.imag()) swap(a, b);",
      "    if (a.imag() < P_eps && P_eps < b.imag() && cross(a, b) > P_eps) f = !f;",
      "  }",
      "  return f; //\u5185\u90e8 or \u5916\u90e8",
      "}",
      "",
      "/* \u5c04\u5f71(\u76f4\u7ddaab\u3068p\u304b\u3089\u306e\u5782\u7dda\u3068\u306e\u4ea4\u70b9) */",
      "P getProject(P a, P b, P p) {",
      "  P base = b - a;",
      "  return a + base * dot(p - a, base) / norm(base);",
      "}",
      "",
      "/* \u53cd\u5c04(\u76f4\u7ddaab\u3092\u5bfe\u79f0\u8ef8\u3068\u3057\u305fp\u306e\u7dda\u5bfe\u79f0\u306e\u4f4d\u7f6e) */",
      "P getReflection(P a, P b, P p) {",
      "  return p + (getProject(a, b, p) - p) * (P_type)2.0;",
      "}",
      "",
      "/* \u591a\u89d2\u5f62\u9762\u7a4d */",
      "G_real getAreaPoly(vector<P> &g) {",
      "  P_type res = 0;",
      "  for (int i = 0; i < (int)g.size(); i++)",
      "    res += cross(g[i], g[(i + 1) % g.size()]);",
      "  return abs(res / 2.0);",
      "}",
      "",
      "/* \u5186\u306e\u5171\u901a\u9762\u7a4d */",
      "G_real getAreaCC(P c1, P_type r1, P c2, P_type r2) {",
      "  G_real d = abs(c1 - c2);",
      "  if (r1 + r2 <= d + P_eps) {",
      "    return 0.0;",
      "  } else if (d <= abs(r1 - r2) + P_eps) {",
      "    G_real r = min(r1, r2);",
      "    return r * r * M_PI;",
      "  } else {",
      "    G_real res = 0;",
      "    for (int i = 0; i < 2; i++) {",
      "      G_real rc = (G_real)(norm(c1 - c2) + r1 * r1 - r2 * r2) / (2 * d * r1);",
      "      G_real theta = acos(rc) * 2;",
      "      res += (theta - sin(theta)) * r1 * r1 / 2;",
      "      swap(r1, r2);",
      "      swap(c1, c2);",
      "    }",
      "    return res;",
      "  }",
      "}",
      "",
      "/* \u5186-\u76f4\u7dda(\u4e2d\u5fc3\u3068\u306e\u4e09\u89d2\u5f62) \u5171\u901a\u9762\u7a4d */",
      "G_real getAreaCS(P c, P_type r, P a1, P a2) {",
      "  if (min({abs(a1 - a2), abs(c - a1), abs(c - a2), r}) <= P_eps) return 0;",
      "",
      "  G_real res = 0;",
      "  vector<P> vec = {a1};",
      "  for (auto p : getCrosspointCS(c, r, a1, a2)) vec.push_back(p);",
      "  vec.push_back(a2);",
      "",
      "  for (int i = 0; i + 1 < (int)vec.size(); i++) {",
      "    P p1 = vec[i] - c, p2 = vec[i + 1] - c;",
      "    if (max(abs(p1), abs(p2)) <= r + P_eps)",
      "      res += cross(p1, p2) / 2.0;",
      "    else",
      "      res += r * r * arg(conj(p1) * p2) / 2.0;",
      "  }",
      "",
      "  return res;",
      "}",
      "",
      "/* \u5186-\u591a\u89d2\u5f62\u5171\u901a\u9762\u7a4d */",
      "G_real getAreaPolyC(vector<P> &g, P c, P_type r) {",
      "  G_real res = 0;",
      "  for (int i = 0; i < (int)g.size(); i++)",
      "    res += getAreaCS(c, r, g[i], g[(i + 1) % g.size()]);",
      "  return abs(res);",
      "}",
      "",
      "/* \u51f8\u591a\u89d2\u5f62\u306e\u5207\u65ad */",
      "// \u76f4\u7ddaA\u3067\u5207\u65ad\u3057\u3001a1\u304b\u3089a2\u65b9\u5411\u306b\u898b\u305f\u3068\u304d\u306b\u76f4\u7ddaA\u306e\u5de6\u5074\u306b\u3067\u304d\u308b\u51f8\u591a\u89d2\u5f62\u3092\u8fd4\u3059",
      "vector<P> convexCut(const vector<P> &g, P a1, P a2) {",
      "  vector<P> res;",
      "  P prev = *g.rbegin();",
      "  for (P now : g) {",
      "    if (ccw(a1, a2, prev) != -1) res.push_back(prev);",
      "    int c = ccw(a1, a2, prev) * ccw(a1, a2, now);",
      "    if (-4 < c && c < 0) {",
      "      res.push_back(getCrosspointLL(prev, now, a1, a2)[0]);",
      "    }",
      "    prev = now;",
      "  }",
      "  return res;",
      "}",
      "",
      "/* \u51f8\u591a\u89d2\u5f62\u306e\u76f4\u5f84(\u6700\u9060\u9802\u70b9\u5bfe\u9593\u8ddd\u96e2) */",
      "// \u53cd\u6642\u8a08\u56de\u308a\u306e\u307f",
      "G_real convexDiameter(const vector<P> &g) {",
      "  int N = g.size(), is = 0, js = 0;",
      "  for (int i = 1; i < N; i++) {",
      "    if (imag(g[i]) > imag(g[is])) is = i;",
      "    if (imag(g[i]) < imag(g[js])) js = i;",
      "  }",
      "",
      "  G_real maxd = abs(g[is] - g[js]);",
      "",
      "  int i, maxi, j, maxj;",
      "  i = maxi = is;",
      "  j = maxj = js;",
      "",
      "  do {",
      "    if (cross(g[(i + 1) % N] - g[i], g[(j + 1) % N] - g[j]) >= 0)",
      "      j = (j + 1) % N;",
      "    else",
      "      i = (i + 1) % N;",
      "",
      "    if (abs(g[i] - g[j]) > maxd) {",
      "      maxd = abs(g[i] - g[j]);",
      "      maxi = i;",
      "      maxj = j;",
      "    }",
      "  } while (i != is || j != js);",
      "",
      "  return maxd; /* farthest pair is {maxi, maxj}. */",
      "}"
    ],
    "description": "Geometry Library"
  },
  "Geometry 3D Library": {
    "prefix": "geo3d",
    "body": [
      "/* 3\u6b21\u5143\u5e7e\u4f55 */",
      "",
      "typedef double P_type;",
      "typedef double G_real; //\u5b9f\u6570\u306e\u623b\u308a\u5024(float or double or long double)",
      "const G_real P_eps = 1e-8; //\u6574\u6570\u306e\u6642\u306f\u30bc\u30ed",
      "",
      "struct P3 {",
      "  P_type x, y, z;",
      "  P3(P_type x = 0, P_type y = 0, P_type z = 0): x(x), y(y), z(z) {}",
      "",
      "  P3 operator-() const {",
      "    return P3(-x, -y, -z);",
      "  }",
      "",
      "  P3 operator+(const P3 &B) const {",
      "    return P3(x + B.x, y + B.y, z + B.z);",
      "  }",
      "",
      "  P3 operator-(const P3 &B) const {",
      "    return P3(x - B.x, y - B.y, z - B.z);",
      "  }",
      "",
      "  P3 operator*(P_type a) const {",
      "    return P3(x * a, y * a, z * a);",
      "  }",
      "",
      "  P3 operator/(P_type a) const {",
      "    return P3(x / a, y / a, z / a);",
      "  }",
      "",
      "  P3 &operator+=(const P3 &B) {",
      "    x += B.x;",
      "    y += B.y;",
      "    z += B.z;",
      "    return *this;",
      "  }",
      "",
      "  P3 &operator-=(const P3 &B) {",
      "    x -= B.x;",
      "    y -= B.y;",
      "    z -= B.z;",
      "    return *this;",
      "  }",
      "",
      "  P3 &operator*=(P_type a) {",
      "    x *= a;",
      "    y *= a;",
      "    z *= a;",
      "    return *this;",
      "  }",
      "",
      "  P3 &operator/=(P_type a) {",
      "    x /= a;",
      "    y /= a;",
      "    z /= a;",
      "    return *this;",
      "  }",
      "",
      "  bool operator<(const P3 &b) {",
      "    if (abs(x - b.x) > P_eps) return x + P_eps < b.x;",
      "    if (abs(y - b.y) > P_eps) return y + P_eps < b.y;",
      "    return z + P_eps < b.z;",
      "  }",
      "};",
      "",
      "ostream &operator<<(ostream &st, const P3 &p) {",
      "  return st << \"(\" << p.x << \", \" << p.y << \", \" << p.z << \")\";",
      "}",
      "",
      "P_type dot(P3 a, P3 b) {",
      "  return a.x * b.x + a.y * b.y + a.z * b.z;",
      "}",
      "",
      "P3 cross(P3 a, P3 b) {",
      "  P_type x = a.y * b.z - a.z * b.y;",
      "  P_type y = a.z * b.x - a.x * b.z;",
      "  P_type z = a.x * b.y - a.y * b.x;",
      "  return P3(x, y, z);",
      "}",
      "",
      "P_type norm(P3 a) {",
      "  return dot(a, a);",
      "}",
      "",
      "double abs(P3 a) {",
      "  return sqrt(dot(a, a)); //sqrtl",
      "}",
      "",
      "/* \u30d9\u30af\u30c8\u30eba, b\u306e\u6210\u3059\u89d2[0, pi] */",
      "G_real arg(P3 a, P3 b) {",
      "  return acos(dot(a, b) / abs(a) / abs(b)); //acosl",
      "}",
      "",
      "/* \u70b9A\u306e\u5e73\u9762Pl\u3078\u306e\u6b63\u5c04\u5f71 */",
      "P3 getProject(P3 a, P3 pl1, P3 pl2, P3 pl3) {",
      "  P3 n = cross(pl2 - pl1, pl3 - pl1);",
      "  return a - n * dot(n, a - pl1) / norm(n);",
      "}",
      "",
      "/* \u76f4\u7ddaab\u3068\u70b9c\u306e\u8ddd\u96e2 */",
      "G_real distanceLP(P3 a, P3 b, P3 c) {",
      "  return abs(cross(b - a, c - a)) / abs(b - a);",
      "}",
      "",
      "/* \u7dda\u5206ab\u3068\u70b9c\u306e\u8ddd\u96e2 */",
      "G_real distanceSP(P3 a, P3 b, P3 c) {",
      "  if (dot(b - a, c - a) <= P_eps) return abs(c - a);",
      "  if (dot(a - b, c - b) <= P_eps) return abs(c - b);",
      "  return abs(cross(b - a, c - a)) / abs(b - a);",
      "}",
      "",
      "/* \u76f4\u7ddaA\u3068\u76f4\u7ddaB\u306e\u8ddd\u96e2 (\u672a\u691c\u8a3c) */",
      "G_real distanceLL(P3 a1, P3 a2, P3 b1, P3 b2) {",
      "  P3 n = cross(a2 - a1, b2 - b1);",
      "  if (abs(n) <= P_eps) return distanceLP(a1, a2, b1); //\u5e73\u884c",
      "  return abs(dot(n, b1 - a1)) / abs(n);",
      "}",
      "",
      "/* \u7dda\u5206A\u3068\u7dda\u5206B\u306e\u8ddd\u96e2(\u672a\u691c\u8a3c) */",
      "G_real distanceSS(P3 a1, P3 a2, P3 b1, P3 b2) {",
      "  //\u306d\u3058\u308c\u306e\u4f4d\u7f6e",
      "  P3 n = cross(a2 - a1, b2 - b1);",
      "  if (abs(n) > P_eps) { // \u5e73\u884c\u3067\u306f\u306a\u3044",
      "    n /= abs(n);",
      "    G_real d = distanceLL(a1, a2, b1, b2);",
      "    P3 p = n * dot(n, b1 - a1);",
      "    P3 c1 = b1 + p, c2 = b2 + p;",
      "",
      "    P3 va = a2 - a1, vc = c2 - c1;",
      "    bool f1 = dot(cross(va, c1 - a1), cross(va, c2 - a1)) < -P_eps;",
      "    bool f2 = dot(cross(vc, a1 - c1), cross(vc, a2 - c1)) < -P_eps;",
      "",
      "    if (f1 && f2) return d;",
      "  }",
      "",
      "  //\u305d\u306e\u4ed6",
      "  return min({distanceSP(a1, a2, b1), distanceSP(a1, a2, b2),",
      "    distanceSP(b1, b2, a1), distanceSP(b1, b2, a2)});",
      "}",
      "",
      "/* \u70b9\u3068\u5e73\u9762Pl\u306e\u8ddd\u96e2 */",
      "G_real distancePPl(P3 p, P3 pl1, P3 pl2, P3 pl3) {",
      "  P3 n = cross(pl2 - pl1, pl3 - pl1);",
      "  assert(abs(n) > P_eps); //3\u70b9\u304c\u540c\u4e00\u76f4\u7dda\u4e0a\u3067\u306a\u3044",
      "  return abs(dot(p - pl1, n)) / abs(n);",
      "}",
      "",
      "/* \u76f4\u7ddaA\u3068\u3001\u5e73\u9762Pl\u306e\u4ea4\u70b9 */",
      "// verified: AOJ0115",
      "vector<P3> getCrosspointLPl(P3 a1, P3 a2, P3 pl1, P3 pl2, P3 pl3) {",
      "  P3 n = cross(pl2 - pl1, pl3 - pl1); //\u5e73\u9762\u306e\u6cd5\u7dda\u30d9\u30af\u30c8\u30eb",
      "  if (abs(dot(n, a2 - a1)) <= P_eps)",
      "    return {}; //\u5e73\u9762\u3068\u76f4\u7dda\u304c\u5e73\u884c",
      "",
      "  G_real s = dot(pl1 - a1, n), t = dot(a2 - pl1, n);",
      "  P3 c = a1 + (a2 - a1) * (s / (s + t));",
      "  return {c};",
      "}",
      "",
      "/* \u7dda\u5206A\u3068\u3001\u5e73\u9762Pl\u306e\u4ea4\u70b9 */",
      "// verified: AOJ0115",
      "vector<P3> getCrosspointSPl(P3 a1, P3 a2, P3 pl1, P3 pl2, P3 pl3) {",
      "  auto cps = getCrosspointLPl(a1, a2, pl1, pl2, pl3);",
      "  if (cps.empty()) return {};",
      "  if (norm(a1 - cps[0]) > norm(a1 - a2) + P_eps) return {};",
      "  if (norm(a2 - cps[0]) > norm(a1 - a2) + P_eps) return {};",
      "  return cps;",
      "}",
      "",
      "/* \u76f4\u7ddaA, B\u306e\u4ea4\u70b9 */",
      "vector<P3> getCrosspointLL(P3 a1, P3 a2, P3 b1, P3 b2) {",
      "  if (distanceLL(a1, a2, b1, b2) > P_eps) return {};",
      "  P3 a = a2 - a1, b = b2 - b1;",
      "  a /= abs(a);",
      "  b /= abs(b);",
      "  P_type t = dot(a, b);",
      "  if (abs(abs(t) - 1) < P_eps) return {}; //\u5e73\u884c",
      "  return {a1 + a * dot(a1 - b1, a - b * t) / (t * t - 1)}; //\u306d\u3058\u308c\u306e\u4f4d\u7f6e\u306e\u3068\u304d\u306f\u3001A\u5074\u306e\u6700\u8fd1\u70b9",
      "}"
    ],
    "description": "Geometry 3D Library"
  },
  "Line": {
    "prefix": "line",
    "body": [
      "/* Line ax+bx+c=0 */",
      "",
      "// P(x, y)",
      "",
      "struct Line {",
      "  P_type a, b, c;",
      "",
      "  Line(P_type a, P_type b, P_type c): a(a), b(b), c(c) {}",
      "",
      "  //2\u70b9(x1,y1),(x2,y2)\u3092\u901a\u308b\u76f4\u7dda",
      "  Line(P_type x1, P_type y1, P_type x2, P_type y2): a(y1 - y2), b(x2 - x1), c(y1 * (x1 - x2) - x1 * (y1 - y2)) {}",
      "",
      "  // y\u5ea7\u6a19\u304b\u3089x\u5ea7\u6a19\u3092\u53d6\u5f97",
      "  G_real x(double y) {",
      "    return -(G_real)(b * y + c) / a;",
      "  }",
      "",
      "  // x\u5ea7\u6a19\u304b\u3089y\u5ea7\u6a19\u3092\u53d6\u5f97",
      "  G_real y(P_type x) {",
      "    return -(G_real)(a * x + c) / b;",
      "  }",
      "",
      "  // \u70b9p\u3068\u76f4\u7dda\u306e\u8ddd\u96e2",
      "  G_real dist(P p) {",
      "    return abs(a * p.real() + b * p.imag() + c) / sqrt(a * a + b * b);",
      "  }",
      "};",
      "",
      "/* \u5186\u306e\u5171\u901a\u63a5\u7dda */",
      "",
      "vector<Line> getCommonTangents(P c1, P_type r1, P c2, P_type r2) {",
      "  vector<Line> res;",
      "  c2 -= c1;",
      "",
      "  // \u5185\u5305",
      "  if (abs(c2) + min(r1, r2) < max(r1, r2) - P_eps) return res;",
      "",
      "  for (int i = -1; i <= 1; i += 2) {",
      "    for (int j = -1; j <= 1; j += 2) {",
      "      P_type sr = r1 + r2 * i;",
      "      P_type p = sqrt(norm(c2) - sr * sr) * j;",
      "",
      "      P_type xq = r1 * (c2.real() * sr + c2.imag() * p) / norm(c2);",
      "      P_type yq = r1 * (c2.imag() * sr - c2.real() * p) / norm(c2);",
      "",
      "      res.push_back(Line(xq, yq, -r1 * r1 - c1.real() * xq - c1.imag() * yq));",
      "    }",
      "    if (abs(c2) < (r1 + r2) - P_eps) break; //\u5185\u63a5\u7dda\u7121\u3057",
      "  }",
      "",
      "  return res;",
      "}"
    ],
    "description": "Line"
  },
  "Convex Hull": {
    "prefix": "convexhull",
    "body": [
      "/* ConvexHull(\u51f8\u5305) */",
      "",
      "vector<P> ConvexHull(vector<P> s) {",
      "  vector<P> g;",
      "  int m, n = (int)s.size();",
      "",
      "  if (n < 3) return s;",
      "",
      "  sort(s.begin(), s.end());",
      "",
      "  //\u8fba\u4e0a\u306e\u70b9\u3092\u542b\u307e\u306a\u3044\u3068\u304d\u306f\u3001ccw(*, *, *) <= 0 -> ccw(*, *, *) != 1",
      "",
      "  for (int i = 0; i < n; i++) {",
      "    while ((m = g.size()) >= 2 && ccw(g[m - 2], g[m - 1], s[i]) <= 0) g.pop_back();",
      "    g.push_back(s[i]);",
      "  }",
      "",
      "  int t = (int)g.size();",
      "",
      "  for (int i = n - 2; i >= 0; i--) {",
      "    while ((m = g.size()) > t && ccw(g[m - 2], g[m - 1], s[i]) <= 0) g.pop_back();",
      "    g.push_back(s[i]);",
      "  }",
      "",
      "  g.pop_back();",
      "",
      "  return g; //\u53cd\u6642\u8a08\u56de\u308a",
      "}"
    ],
    "description": "Convex Hull"
  },
  "Trie": {
    "prefix": "trie",
    "body": [
      "/* Trie */",
      "",
      "struct Trie {",
      "  int val;",
      "  Trie *next[26];",
      "",
      "  Trie(): val(0) { memset(next, 0, sizeof(next)); }",
      "",
      "  void insert(char *s, bool countPrefix = true) {",
      "    if (countPrefix) val++; //\u63a5\u982d\u8f9e\u306e\u30ab\u30a6\u30f3\u30c8[default]",
      "",
      "    if (*s) {",
      "      int al = *s - 'a';",
      "      if (next[al] == NULL) next[al] = new Trie;",
      "      next[al]->insert(s + 1, countPrefix);",
      "    } else {",
      "      if (!countPrefix) val++; //\u7d42\u7aef\u306e\u30ab\u30a6\u30f3\u30c8",
      "    }",
      "  }",
      "",
      "  int find(char *s) {",
      "    if (*s) {",
      "      int al = *s - 'a';",
      "      return next[al] ? next[al]->find(s + 1) : 0;",
      "    }",
      "    return val;",
      "  }",
      "};"
    ],
    "description": "Trie"
  },
  "Aho Corasick": {
    "prefix": "ahocora",
    "body": [
      "/* Aho Corasick */",
      "",
      "struct ACNode {",
      "  int val;",
      "  ACNode *next[26], *failure;",
      "",
      "  ACNode(): val(0) { memset(next, 0, sizeof(next)); }",
      "",
      "  void insert(char *s) {",
      "    if (!*s) {",
      "      val++;",
      "      return;",
      "    }",
      "    int al = *s - 'a';",
      "    if (next[al] == NULL) next[al] = new ACNode;",
      "    next[al]->insert(s + 1);",
      "  }",
      "",
      "  ACNode *nextNode(char c) {",
      "    int al = c - 'a';",
      "    if (next[al]) return next[al];",
      "    return failure == this ? this : failure->nextNode(c);",
      "  }",
      "};",
      "",
      "struct AhoCorasick {",
      "  ACNode *node;",
      "",
      "  AhoCorasick() { node = new ACNode; }",
      "",
      "  void insert(char *s) {",
      "    node->insert(s);",
      "  }",
      "",
      "  void build() {",
      "    queue<ACNode *> que;",
      "    que.push(node);",
      "    node->failure = node;",
      "",
      "    while (que.size()) {",
      "      ACNode *p = que.front();",
      "      que.pop();",
      "",
      "      for (int i = 0; i < 26; i++) {",
      "        if (p->next[i]) {",
      "          ACNode *failure = p->failure;",
      "          while (!failure->next[i] && failure != node)",
      "            failure = failure->failure;",
      "",
      "          if (failure->next[i] && failure != p) {",
      "            p->next[i]->failure = failure->next[i];",
      "            p->next[i]->val += failure->next[i]->val;",
      "          } else {",
      "            p->next[i]->failure = node;",
      "          }",
      "          que.push(p->next[i]);",
      "        }",
      "      }",
      "    }",
      "  }",
      "};"
    ],
    "description": "Aho Corasick"
  },
  "Recursive Descent Parsing": {
    "prefix": "parsing",
    "body": [
      "/* \u518d\u5e30\u4e0b\u964d\u6cd5 */",
      "// char *p = str; res = expr(p);",
      "",
      "int term(char*& s);",
      "int number(char*& s);",
      "int factor(char*& s);",
      "int expr(char*& s);",
      "",
      "//\u6570",
      "int number(char*& s) {",
      "  int res = 0;",
      "  while ('0' <= *s && *s <= '9')",
      "    res = res * 10 + (*s++ - '0');",
      "  return res;",
      "}",
      "",
      "//\u4e57\u7b97\u9664\u7b97(\u512a\u5148\u9806\u4f4d:\u9ad8)",
      "int term(char*& s) {",
      "  int res = factor(s);",
      "  while (1) {",
      "    if (*s == '*')",
      "      res *= factor(++s);",
      "    else if (*s == '/')",
      "      res /= factor(++s);",
      "    else",
      "      break;",
      "  }",
      "  return res;",
      "}",
      "",
      "//\u62ec\u5f27\u304b\u6570",
      "int factor(char*& s) {",
      "  if (*s != '(') return number(s);",
      "  int res = expr(++s);",
      "  s++;",
      "  return res;",
      "}",
      "",
      "//\u5f0f(\u512a\u5148\u9806\u4f4d: \u4f4e)",
      "int expr(char*& s) {",
      "  int res = term(s);",
      "  while (1) {",
      "    if (*s == '+')",
      "      res += term(++s);",
      "    else if (*s == '-')",
      "      res -= term(++s);",
      "    else",
      "      break;",
      "  }",
      "  return res;",
      "}"
    ],
    "description": "Recursive Descent Parsing"
  },
  "SuffixArray/LCP": {
    "prefix": "suffixarray",
    "body": [
      "/* SuffixArray (Source: \u87fb\u672c) */",
      "",
      "//O(N log^2 N)",
      "//pos[i] := \u63a5\u982d\u8f9e\u306e\u958b\u59cb\u4f4d\u7f6e",
      "//lcp[i] := lcp(s[pos[i]:n-1], s[pos[i-1]:n-1])",
      "struct SuffixArray {",
      "  vector<int> pos, lcp;",
      "",
      "  SuffixArray(const char *S) {",
      "    int n = strlen(S), k;",
      "    vector<int> rank(S, S + n), tmp(n);",
      "    auto comp = [&](const int &i, const int &j) {",
      "      if (rank[i] != rank[j]) return rank[i] < rank[j];",
      "      return (i + k < n ? rank[i + k] : -1) < (j + k < n ? rank[j + k] : -1);",
      "    };",
      "",
      "    pos.resize(n);",
      "    iota(pos.begin(), pos.end(), 0);",
      "",
      "    for (k = 1; k < n; k *= 2) {",
      "      sort(pos.begin(), pos.end(), comp);",
      "      tmp[pos[0]] = 0;",
      "      for (int i = 1; i < n; i++)",
      "        tmp[pos[i]] = tmp[pos[i - 1]] + comp(pos[i - 1], pos[i]);",
      "      for (int i = 0; i < n; i++)",
      "        rank[i] = tmp[i];",
      "    }",
      "",
      "    //LongestCommonPrefixArray",
      "    lcp.resize(n);",
      "    for (int i = 0; i < n; i++) rank[pos[i]] = i;",
      "",
      "    for (int i = 0, h = 0; i < n; i++) {",
      "      if (rank[i] + 1 < n) {",
      "        for (int j = pos[rank[i] + 1]; max(i, j) + h < n && S[i + h] == S[j + h]; h++)",
      "          ;",
      "        lcp[rank[i] + 1] = h;",
      "        if (h > 0) h--;",
      "      }",
      "    }",
      "  }",
      "",
      "  int operator[](int k) const {",
      "    return pos[k];",
      "  }",
      "};"
    ],
    "description": "SuffixArray/LCP"
  },
  "KMP": {
    "prefix": "kmp",
    "body": [
      "/* KMP */",
      "",
      "// A[i] := \u6587\u5b57\u5217S[0,i-1]\u306e\u63a5\u982d\u8f9e\u3068\u63a5\u5c3e\u8f9e\u304c\u6700\u5927\u4f55\u6587\u5b57\u4e00\u81f4\u3057\u3066\u3044\u308b\u304b (i-1\u672a\u6e80)",
      "// len(A) == S.size() + 1",
      "",
      "void KMP(const char *S, int *A) {",
      "  A[0] = -1;",
      "  int j = -1, n = strlen(S);",
      "  for (int i = 0; i < n; i++) {",
      "    while (j >= 0 && S[i] != S[j]) j = A[j];",
      "    j++;",
      "",
      "    //KMP",
      "    //if (S[i+1] == S[j]) A[i+1] = A[j];",
      "    //else A[i+1] = j;",
      "",
      "    //MP",
      "    A[i + 1] = j;",
      "  }",
      "}"
    ],
    "description": "KMP"
  },
  "Manacher": {
    "prefix": "manacher",
    "body": [
      "/* Manacher */",
      "",
      "// R[i] := \u6587\u5b57 i \u3092\u4e2d\u5fc3\u3068\u3059\u308b\u6700\u9577\u306e\u56de\u6587\u306e\u534a\u5f84( \u5168\u9577+1 / 2 )",
      "// \u5076\u6570\u9577\u306f\u6587\u5b57\u9593\u306b\u30c0\u30df\u30fc\u3092\u5165\u308c\u308b(\u4f8b: a#b#a#c#b)",
      "",
      "void Manacher(const char *S, int *R) {",
      "  int i = 0, j = 0, k, n = strlen(S);",
      "  while (i < n) {",
      "    while (i >= j && i + j < n && S[i - j] == S[i + j]) j++;",
      "    R[i] = j;",
      "    for (k = 1; i >= k && i + k < n && k + R[i - k] < j; k++) R[i + k] = R[i - k];",
      "    i += k;",
      "    j -= k;",
      "  }",
      "}"
    ],
    "description": "Manacher"
  },
  "Zalgorithm": {
    "prefix": "zalgo",
    "body": [
      "/* Zalgorithm */",
      "",
      "// A[i] := S \u3068 S[i:|S|-1] \u306e\u6700\u9577\u5171\u901a\u63a5\u982d\u8f9e\u306e\u9577\u3055",
      "",
      "void Zalgorithm(const char *S, int *A) {",
      "  int i = 1, j = 0, k, n = strlen(S);",
      "  A[0] = n;",
      "  while (i < n) {",
      "    while (i + j < n && S[j] == S[i + j]) j++;",
      "    A[i] = j;",
      "    if (j == 0) {",
      "      i++;",
      "      continue;",
      "    }",
      "    for (k = 1; i + k < n && k + A[k] < j; k++) A[i + k] = A[k];",
      "    i += k;",
      "    j -= k;",
      "  }",
      "}"
    ],
    "description": "Zalgorithm"
  },
  "Rolling Hash": {
    "prefix": "rollinghash",
    "body": [
      "/* Rolling Hash */",
      "// n = 9999991, 10000019, 924844033, 1012924417",
      "",
      "struct RollingHash {",
      "  int N, base;",
      "  vector<ll> hash, pow;",
      "",
      "  template<typename Type>",
      "  RollingHash(int base, int n, Type *arr): N(n), base(base), hash(n + 1), pow(n + 1) {",
      "    hash[0] = 0;",
      "    pow[0] = 1;",
      "    for (int i = 0; i < N; i++) {",
      "      hash[i + 1] = (hash[i] + arr[i]) * base % mod;",
      "      pow[i + 1] = pow[i] * base % mod;",
      "    }",
      "  }",
      "",
      "  // get [l,r)",
      "  ll getHash(int l, int r) {",
      "    return (mod + hash[r] - hash[l] * pow[r - l] % mod) % mod;",
      "  }",
      "};"
    ],
    "description": "Rolling Hash"
  },
  "Fairfield": {
    "prefix": "fairfield",
    "body": [
      "/* \u897f\u66a61\u5e741\u67081\u65e5\u304b\u3089\u306e\u7d4c\u904e\u65e5\u6570\u8a08\u7b97 */",
      "ll Fairfield(ll y, int m, int d) {",
      "  if (m <= 2) {",
      "    y--;",
      "    m += 12;",
      "  }",
      "",
      "  ll dy = 365LL * (y - 1);",
      "  int dl = y / 4 - y / 100 + y / 400;",
      "  int dm = (306 * m - 324) / 10;",
      "  return dy + dl + dm + d - 1;",
      "}"
    ],
    "description": "Fairfield"
  },
  "Zeller": {
    "prefix": "zeller",
    "body": [
      "/* \u66dc\u65e5\u8a08\u7b97 (0\u65e5\u66dc\u65e5 - 6\u571f\u66dc\u65e5)\u3000*/",
      "int Zeller(ll y, int m, int d) {",
      "  if (m <= 2) {",
      "    y--;",
      "    m += 12;",
      "  }",
      "  return (y + y / 4 - y / 100 + y / 400 + (13 * m + 8) / 5 + d) % 7;",
      "}"
    ],
    "description": "Zeller"
  },
  "Leap Year": {
    "prefix": "isuruu",
    "body": [
      "/* \u3046\u308b\u3046\u5e74 */",
      "bool is_uruu(int y) {",
      "  return y % 4 == 0 && (y % 100 != 0 || y % 400 == 0);",
      "}"
    ],
    "description": "Leap Year"
  },
  "XOR Shift": {
    "prefix": "xorshift",
    "body": [
      "/* Xorshift */",
      "#include <cstdlib>",
      "",
      "typedef unsigned long long ull;",
      "typedef unsigned int uint;",
      "",
      "uint xor64() {",
      "  static ull x = ((ull)rand() << 32) + rand();",
      "  x = x ^ (x << 13);",
      "  x = x ^ (x >> 7);",
      "  return x = x ^ (x << 17);",
      "}",
      "",
      "ull xor64ll() {",
      "  static ull x = ((ull)rand() << 32) + rand();",
      "  x = x ^ (x << 7);",
      "  return x = x ^ (x >> 9);",
      "}",
      "",
      "uint xor128() {",
      "  static uint x = 123456789;",
      "  static uint y = 362436069;",
      "  static uint z = 521288629;",
      "  static uint w = rand();",
      "  uint t;",
      "",
      "  t = x ^ (x << 11);",
      "  x = y;",
      "  y = z;",
      "  z = w;",
      "  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));",
      "}"
    ],
    "description": "XOR Shift"
  },
  "ModInt": {
    "prefix": "modint",
    "body": [
      "template<int M = mod>",
      "struct ModInt {",
      "  using ll = long long;",
      "  ll val;",
      "",
      "  ModInt(ll x = 0): val(x >= 0 ? x % M : (x % mod + mod) % mod) {}",
      "",
      "  explicit operator bool() const { return val != 0; }",
      "",
      "  ModInt operator+() const { return *this; }",
      "  ModInt operator-() const { return ModInt(-val); }",
      "",
      "  ModInt operator+(const ModInt &rhs) const { return ModInt(*this) += rhs; }",
      "  ModInt operator-(const ModInt &rhs) const { return ModInt(*this) -= rhs; }",
      "  ModInt operator*(const ModInt &rhs) const { return ModInt(*this) *= rhs; }",
      "  ModInt operator/(const ModInt &rhs) const { return ModInt(*this) /= rhs; }",
      "",
      "  bool operator==(const ModInt &rhs) const { return val == rhs.val; }",
      "  bool operator!=(const ModInt &rhs) const { return val != rhs.val; }",
      "  bool operator<(const ModInt &rhs) const { return val < rhs.val; }",
      "  bool operator>(const ModInt &rhs) const { return val > rhs.val; }",
      "  bool operator<=(const ModInt &rhs) const { return val <= rhs.val; }",
      "  bool operator>=(const ModInt &rhs) const { return val >= rhs.val; }",
      "",
      "  ModInt operator++() { return *this += 1; }",
      "  ModInt operator--() { return *this -= 1; }",
      "  ModInt operator++(int) { return ++*this, *this - 1; }",
      "  ModInt operator--(int) { return --*this, *this + 1; }",
      "",
      "  ModInt &operator+=(const ModInt &rhs) {",
      "    val += rhs.val;",
      "    if (val >= M) val -= M;",
      "    return *this;",
      "  }",
      "  ModInt &operator-=(const ModInt &rhs) {",
      "    val -= rhs.val;",
      "    if (val < 0) val += M;",
      "    return *this;",
      "  }",
      "  ModInt &operator*=(const ModInt &rhs) {",
      "    val = val * rhs.val % M;",
      "    return *this;",
      "  }",
      "  ModInt &operator/=(ModInt rhs) {",
      "    for (int exp = M - 2; exp; exp /= 2) {",
      "      if (exp % 2) *this *= rhs;",
      "      rhs *= rhs;",
      "    }",
      "    return *this;",
      "  }",
      "",
      "  friend ostream &operator<<(ostream &os, const ModInt &rhs) {",
      "    return os << rhs.val;",
      "  }",
      "",
      "  friend istream &operator>>(istream &is, ModInt &rhs) {",
      "    ll x;",
      "    is >> x;",
      "    rhs = ModInt(x);",
      "    return is;",
      "  }",
      "};"
    ],
    "description": "ModInt"
  },
  "Coordinate Compression": {
    "prefix": "compress",
    "body": [
      "/* Coordinate Compression */",
      "",
      "template<typename T>",
      "map<T, int> compress(vector<T> &vec) {",
      "  sort(vec.begin(), vec.end());",
      "  vec.erase(unique(vec.begin(), vec.end()), vec.end());",
      "",
      "  map<T, int> dict;",
      "  for (int i = 0; i < (int)vec.size(); i++) {",
      "    dict[vec[i]] = i;",
      "  }",
      "  return dict;",
      "}"
    ],
    "description": "Coordinate Compression"
  },
  "Dx Dy": {
    "prefix": "dxdy",
    "body": [
      "int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1};",
      "int dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};",
      "char dirchar[] = \"DURL\"; // \"SNWE\""
    ],
    "description": "Dx Dy"
  }
}