{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	"競プロ用template": {
		"prefix": "temp",
		"body": [
			"#include <bits/stdc++.h>",
			"#ifdef _DEBUG",
			"#include \"_DEBUG.hpp\"",
			"#endif",
			"#define int long long",
			"using namespace std;",
			"using P = pair<int, int>;",
			"const int inf = 2e18;",
			"const int mod = 1e9 + 7;",
			"",
			"template <typename T>",
			"istream &operator>>(istream &is, vector<T> &v) {",
			"  for (T &in : v) is >> in;",
			"  return is;",
			"}",
			"",
			"template <class T>",
			"vector<T> make_vec(size_t a) {",
			"  return vector<T>(a);",
			"}",
			"",
			"template <class T, class... Ts>",
			"auto make_vec(size_t a, Ts... ts) {",
			"  return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));",
			"}",
			"",
			"template <class T, class V>",
			"typename enable_if<is_class<T>::value == 0>::type fill(T &t, const V &v) {",
			"  t = v;",
			"}",
			"",
			"template <class T, class V>",
			"typename enable_if<is_class<T>::value != 0>::type fill(T &t, const V &v) {",
			"  for (auto &e : t) fill(e, v);",
			"}",
			"",
			"signed main() {",
			"  ",
			"  $0",
			"",
			"  return 0;",
			"}"
		],
		"description": "競プロ用template"
	},
	"IoSetup": {
		"prefix": "iosetup",
		"body": [
			"struct IoSetup {",
			"  IoSetup() {",
			"    cin.tie(nullptr);",
			"    ios::sync_with_stdio(false);",
			"    cout << fixed << setprecision(10);",
			"    cerr << fixed << setprecision(10);",
			"  }",
			"} iosetup;",
			"#define endl '\\n'",
		],
		"description": "IoSetup"
	},
	"comment": {
		"prefix": "commet",
		"body": [
			"/* ----- $1 ----- */$0"
		],
		"description": "comment"
	},
	"for(i, n)": {
		"prefix": "repeat",
		"body": [
			"for (int ${1:i} = 0; ${1:i} < ${2:n}; ${1:i}++) {",
			"  $0",
			"}"
		],
		"description": "for"
	},
	"dx dy": {
		"prefix": "repeat4",
		"body": [
			"int dy[4] = {1, 0, -1, 0}, dx[4] = {0, 1, 0, -1};",
			"for (int i = 0; i < 4; i++) {",
			"  int ny = y + dy[i];",
			"  int nx = x + dx[i];",
			"  if (ny < 0 || h <= ny || nx < 0 || w <= nx) continue;",
			"}"
		],
		"description": "dx dy"
	},
	"printf(double)": {
		"prefix": "printf",
		"body": [
			"printf(\"%.9f\\n\", $1);"
		],
		"description": "printf(double)"
	},
	"v.begin(), v.end()": {
		"prefix": "all",
		"body": [
			"$1.begin(), $1.end()$0"
		],
		"description": "v.begin(), v.end()"
	},
	"push_back": {
		"prefix": "push",
		"body": [
			"push_back($0)"
		],
		"description": "push_back"
	},
	"edge": {
		"prefix": "edge",
		"body": [
			"struct edge { int to, cost; };"
		],
		"description": "edge"
	},
	"erase_vector": {
		"prefix": "erase",
		"body": [
			"$1.erase(unique($1.begin(),$1.end()),$1.end());"
		],
		"description": "erase_vector"
	},
	"priority_queue": {
		"prefix": "priority",
		"body": [
			"priority_queue<$1, vector<$1>, greater<$1>> q;$0"
		],
		"description": "priority_queue"
	},
	"operator(構造体用)": {
		"prefix": "operator",
		"body": [
			"bool operator<(const ${1:Data}& p) const { return ${2:cost} < p.${2:cost}; }",
			"bool operator>(const ${1:Data}& p) const { return ${2:cost} > p.${2:cost}; }",
		],
		"description": "operator(構造体用)"
	},
	"binary_search": {
		"prefix": "binary_search",
		"body": [
			"int left = -1, right = n;",
			"while(right - left > 1){",
			"  int mid = (left + right) / 2;",
			"  ( ? right : left) = mid;",
			"}"
		],
		"description": "binary_search"
	},
	"power": {
		"prefix": "power",
		"body": [
			"int power(int n, int p) {",
			"  int r = 1;",
			"  for (; p > 0; p >>= 1) {",
			"    if (p & 1ll) r = r * n % mod;",
			"    n = n * n % mod;",
			"  }",
			"  return r;",
			"}"
		],
		"description": "power"
	},
	"invese": {
		"prefix": "inverse",
		"body": [
			"int inv(int n, int p = mod - 2) {",
			"  int r = 1;",
			"  for (; p > 0; p >>= 1) {",
			"    if (p & 1LL) r = r * n % mod;",
			"    n = n * n % mod;",
			"  }",
			"  return r;",
			"}"
		],
		"description": "inverse"
	},
	"sanbun": {
		"prefix": "sanbun",
		"body": [
			"auto f = [&](int x){",
			"  return x;",
			"};",
			"",
			"int left = 0, right = inf;",
			"while (right - left > 10) {",
			"  int t1 = (left * 2 + right) / 3;",
			"  int t2 = (left + right * 2) / 3;",
			"  if (f(t1) > f(t2))",
			"    left = t1;",
			"  else",
			"    right = t2;",
			"}"
		],
		"description": "sanbun"
	},
	"__builtin_popcountll": {
		"prefix": "popcount",
		"body": [
			"__builtin_popcountll($0)"
		],
		"description": "__builtin_popcountll()"
	},
	"Stoi": {
		"prefix": "stoi",
		"body": [
			"int mystoi(string s){",
			"  int res = 0, t = 1;",
			"  for(int i = (int)s.size()-1; i >= 0; i--){",
			"    res += (s[i]-'0') * t;",
			"    t *= 10;",
			"  }",
			"  return res;",
			"}"
		],
		"description": "MyStoi"
	},
	"dfs": {
		"prefix": "dfs",
		"body": [
			"auto dfs = [&](auto&& dfs, int u, int par)->void{",
			"  for(int v : g[u]){",
			"    if(v == par) continue;",
			"    dfs(dfs, v, u);",
			"  }",
			"};"
		],
		"description": "dfs"
	},
	"Prime": {
		"prefix": "prime",
		"body": [
			"struct Prime {",
			"  vector<int> prime;      // 2,3,5,7,11...",
			"  vector<bool> is_prime;  // 素数=1,合成数=0",
			"  vector<int> div;        // iを割り切れる最小の素数",
			"  Prime(int n) {",
			"    is_prime.resize(n + 1, true);",
			"    is_prime[0] = is_prime[1] = false;",
			"    div.resize(n + 1, 1);",
			"    for (int i = 2; i <= n; i++) {",
			"      if (is_prime[i]) {",
			"        prime.push_back(i);",
			"        div[i] = i;",
			"        for (int j = i * 2; j <= n; j += i) {",
			"          is_prime[j] = false;",
			"          div[j] = i;",
			"        }",
			"      }",
			"    }",
			"  }",
			"",
			"  //高速因数分解",
			"  map<int, int> factor(int n) {",
			"    map<int, int> mp;  //{約数,個数}",
			"    while (n != 1) {",
			"      mp[div[n]]++;",
			"      n /= div[n];",
			"    }",
			"    return mp;",
			"  }",
			"};",
			""
		],
		"description": "Prime"
	},
	"Combination": {
		"prefix": "comb",
		"body": [
			"struct Combination{",
			"  vector<int> fact; //　fact[i] = iの階乗",
			"  Combination(int n) : fact(n+1){",
			"    fact[0] = fact[1] = 1;",
			"    for(int i = 2; i <= n; i++){",
			"      fact[i] = fact[i-1] * i % mod;",
			"    }",
			"  }",
			"",
			"  int nCr(int n, int r){ // nCr = n!/r!(n-r)!",
			"    if(n < r) return 0;",
			"    return fact[n] * inv(fact[r]*fact[n-r]%mod) % mod;",
			"  }",
			"",
			"  int inv(int n, int p = mod-2){ // a/n ≡ a*n^(p-2) nとpは互いに素",
			"    int r = 1;",
			"    for(; p > 0; p >>= 1){",
			"      if(p & 1LL) r = r * n % mod;",
			"      n = n * n % mod;",
			"    }",
			"    return r; // r = n^p % mod",
			"  }",
			"};"
		],
		"description": "Combination"
	},
	"Combination(dp)": {
		"prefix": "combination",
		"body": [
			"vector<vector<int>> Combination_dp(int n){",
			"  vector<vector<int>> dp(n+1,vector<int>(n+1)); //dp[n][r] = nCr",
			"  for(int i = 0; i <= n; i++){",
			"    dp[i][0] = 1;",
			"    for(int j = 1; j <= i; j++){",
			"      dp[i][j] = dp[i-1][j-1] + dp[i-1][j];",
			"    }",
			"  }",
			"  return dp;",
			"}"
		],
		"description": "Combination(dp)"
	},
	"Longest-Increasing-Subsequence": {
		"prefix": "lis",
		"body": [
			"int LIS(vector<int> a) {",
			"  int n = a.size();",
			"  vector<int> dp(n, inf);  //長さをiとしたときの末尾の最小値",
			"  for (int i = 0; i < n; i++) {",
			"    int j = lower_bound(dp.begin(), dp.end(), a[i]) - dp.begin();",
			"    dp[j] = a[i];",
			"  }",
			"  return lower_bound(dp.begin(), dp.end(), inf) - dp.begin();",
			"}"
		],
		"description": "Longest-Increasing-Subsequence"
	},
	"UnionFind": {
		"prefix": "unionfind",
		"body": [
			"struct UnionFind {",
			"  vector<int> par;   //親",
			"  vector<int> size;  //集合の大きさ",
			"",
			"  UnionFind(int n) {",
			"    par.resize(n);",
			"    size.resize(n, 1);",
			"    for (int i = 0; i < n; i++) {",
			"      par[i] = i;",
			"    }",
			"  }",
			"",
			"  //木の根を求める",
			"  int root(int x) {",
			"    if (par[x] == x) {",
			"      return x;",
			"    } else {",
			"      return par[x] = root(par[x]);",
			"    }",
			"  }",
			"",
			"  // xとyの属する集合を併合",
			"  void unite(int x, int y) {",
			"    x = root(x), y = root(y);",
			"    if (x == y) return;",
			"    if (size[x] < size[y]) swap(x, y);",
			"    par[y] = x;",
			"    size[x] += size[y];",
			"  }",
			"",
			"  bool same(int x, int y) { return root(x) == root(y); }",
			"};",
			""
		],
		"description": "UnionFind"
	},
	"dikstra": {
		"prefix": "dikstra",
		"body": [
			"struct edge{ int to, cost; };",
			"vector<int> dikstra(vector<vector<edge>> G, int s){",
			"  using P = pair<int, int>;",
			"  priority_queue<P,vector<P>,greater<P>> q;",
			"  vector<int> d(G.size(), inf); //sからの最短距離",
			"  d[s] = 0;",
			"  q.push({0, s}); //{最短距離,頂点}",
			"",
			"  while(!q.empty()){",
			"    auto p = q.top(); q.pop();",
			"    int v = p.second;",
			"    if(d[v] < p.first) continue;",
			"    for(auto e : G[v]){",
			"      if(d[e.to] > d[v] + e.cost){",
			"        d[e.to] = d[v] + e.cost;",
			"        q.push(P(d[e.to], e.to));",
			"      }",
			"    }",
			"  }",
			"  return d;",
			"}"
		],
		"description": "dikstra"
	},
	"WarshallFloyd": {
		"prefix": "warshall",
		"body": [
			"vector<vector<int>> warshall_floyd(vector<vector<edge>> G){",
			"  int n = G.size();",
			"  vector<vector<int>> dp(n, vector<int> (n, 1LL << 60));",
			"  for(int i = 0; i < n; i++){",
			"    for(edge e : G[i]){",
			"      dp[i][e.to] = e.cost;",
			"    }",
			"    dp[i][i] = 0;",
			"  }",
			"  for(int k = 0; k < n; k++){ //経由する頂点",
			"    for(int i = 0; i < n; i++){",
			"      for(int j = 0; j < n; j++){",
			"        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);",
			"      }",
			"    }",
			"  }",
			"  return dp;",
			"}"
		],
		"description": "WarshallFloyd"
	},
	"Kruskal": {
		"prefix": "kurskal",
		"body": [
			"struct edge {",
			"  int u, v, cost;",
			"  bool operator<(const edge &p) const { return cost < p.cost; }",
			"};",
			"vector<edge> es;",
			"",
			"UnionFind uf(n);",
			"int total = 0;",
			"sort(es.begin(), es.end());",
			"for (auto [u, v, cost] : es) {",
			"  if (!uf.same(u, v)) {",
			"    uf.unite(u, v);",
			"    total += cost;",
			"  }",
			"}"
		],
		"description": "Kurskal"
	},
	"Doubling": {
		"prefix": "doubling",
		"body": [
			"struct Doubling {",
			"  const int LOG = 63;",
			"  vector< vector< int > > table;",
			" ",
			"  Doubling(int sz) {",
			"    table.assign(LOG, vector< int >(sz, -1));",
			"  }",
			" ",
			"  void set_next(int k, int x) {",
			"    table[0][k] = x;",
			"  }",
			" ",
			"  void build() {",
			"    for(int k = 0; k + 1 < LOG; k++) {",
			"      for(int i = 0; i < table[k].size(); i++) {",
			"        if(table[k][i] == -1) table[k + 1][i] = -1;",
			"        else table[k + 1][i] = table[k][table[k][i]];",
			"      }",
			"    }",
			"  }",
			" ",
			"  int query(int k, int64_t t) {",
			"    for(int i = LOG - 1; i >= 0; i--) {",
			"      if((t >> i) & 1) k = table[i][k];",
			"    }",
			"    return k;",
			"  }",
			"};"
		],
		"description": "Doubling"
	},
	"mod_int": {
		"prefix": "mod",
		"body": [
			"template< int mod >",
			"struct ModInt {",
			"  int x;",
			"  ModInt() : x(0) {}",
			"  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}",
			"  ModInt &operator+=(const ModInt &p) {",
			"    if((x += p.x) >= mod) x -= mod;",
			"    return *this;",
			"  }",
			"  ModInt &operator-=(const ModInt &p) {",
			"    if((x += mod - p.x) >= mod) x -= mod;",
			"    return *this;",
			"  }",
			"  ModInt &operator*=(const ModInt &p) {",
			"    x = (int) (1LL * x * p.x % mod);",
			"    return *this;",
			"  }",
			"  ModInt &operator/=(const ModInt &p) {",
			"    *this *= p.inverse();",
			"    return *this;",
			"  }",
			"  ModInt operator-() const { return ModInt(-x); }",
			"  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }",
			"  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }",
			"  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }",
			"  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }",
			"  bool operator==(const ModInt &p) const { return x == p.x; }",
			"  bool operator!=(const ModInt &p) const { return x != p.x; }",
			"  ModInt inverse() const {",
			"    int a = x, b = mod, u = 1, v = 0, t;",
			"    while(b > 0) {",
			"      t = a / b;",
			"      swap(a -= t * b, b);",
			"      swap(u -= t * v, v);",
			"    }",
			"    return ModInt(u);",
			"  }",
			"  ModInt pow(int64_t n) const {",
			"    ModInt ret(1), mul(x);",
			"    while(n > 0) {",
			"      if(n & 1) ret *= mul;",
			"      mul *= mul;",
			"      n >>= 1;",
			"    }",
			"    return ret;",
			"  }",
			"  friend ostream &operator<<(ostream &os, const ModInt &p) {",
			"    return os << p.x;",
			"  }",
			"  friend istream &operator>>(istream &is, ModInt &a) {",
			"    int64_t t;",
			"    is >> t;",
			"    a = ModInt< mod >(t);",
			"    return (is);",
			"  }",
			"};",
			"using mint = ModInt< 1000000007 >;"
		],
		"description": "mod_int",
	},
	"SegmentTree": {
		"prefix": "segment",
		"body": [
			"template <class T>",
			"struct SegmentTree{",
			"  using F = function<T(T, T)>;",
			"  F f;",
			"  T inf;",
			"  int n;",
			"  vector<T> node;",
			"",
			"  SegmentTree(){}",
			"  SegmentTree(vector<T> v, T inf, F f) : inf(inf), f(f){",
			"    n = 1; while(n < v.size()) n *= 2;",
			"    node.resize(2*n-1, inf);",
			"    for(int i = 0; i < v.size(); i++) node[i+n-1] = v[i];",
			"    for(int i = n-2; i >= 0; i--) node[i] = f(node[2*i+1], node[2*i+2]);",
			"  }",
			"",
			"  void update(int k, T val){",
			"    k += n-1;",
			"    node[k] = val;",
			"    while(k > 0){",
			"      k = (k-1) / 2;",
			"      node[k] = f(node[2*k+1], node[2*k+2]);",
			"    }",
			"  }",
			"",
			"  void add(int k, T val){",
			"    k += n-1;",
			"    node[k] += val;",
			"    while(k > 0){",
			"      k = (k-1) / 2;",
			"      node[k] = f(node[2*k+1], node[2*k+2]);",
			"    }",
			"  }",
			"",
			"  //区間[a, b)の値を返す",
			"  T operator[](int x){ return getval(x, x + 1); }",
			"  T getval(int a, int b){ return getval(a, b, 0, 0, n); }",
			"  T getval(int a, int b, int k, int l, int r){",
			"    if(r <= a || b <= l) return inf;",
			"    if(a <= l && r <= b) return node[k];",
			"    T vl = getval(a, b, 2*k+1, l, (l+r)/2);",
			"    T vr = getval(a, b, 2*k+2, (l+r)/2, r);",
			"    return f(vl, vr);",
			"  }",
			"",
			"  void print(int n){",
			"    for(int i = 0; i < n; i++){",
			"      cout << getval(i, i+1) << \" \";",
			"    }",
			"    cout << endl;",
			"  }",
			"};"
		],
		"description": "SegmentTree",
	},
	"Segment-min": {
		"prefix": "segment",
		"body": [
			"SegmentTree<int> seg(vector<int>(n, 0), inf, [&](int x, int y){ return min(x, y); });"
		],
		"description": "区間最小"
	},
	"Segment-sum": {
		"prefix": "segment",
		"body": [
			"SegmentTree<int> seg(vector<int>(n, 0), 0, [&](int x, int y){ return (x + y); });"
		],
		"description": "区間和"
	},
	"Segment-pair": {
		"prefix": "segment",
		"body": [
			"SegmentTree<P> seg(vector<P>(n, P(inf, inf)), P(inf, inf), [&](P x, P y){ return min(x, y); });"
		],
		"description": "区間最小 + idx"
	},
	"SegTreeLazyProportional": {
		"prefix": "segment",
		"body": [
			"/* SegTreeLazyProportional<X,M>(n,fx,fa,fm,fp,ex,em): モノイド(集合X,",
			"   二項演算fx,fa,fm,p 単位元ex,em)についてサイズnで構築 set(int i, X x),",
			"   build(): i番目の要素をxにセット。まとめてセグ木を構築する。O(n) update(i,x):",
			"   i 番目の要素を x に更新。O(log(n)) query(a,b):  [a,b)",
			"   全てにfxを作用させた値を取得。O(log(n))",
			"*/",
			"template <typename X, typename M>",
			"struct SegTreeLazyProportional {",
			"  using FX = function<X(X, X)>;",
			"  using FA = function<X(X, M)>;",
			"  using FM = function<M(M, M)>;",
			"  using FP = function<M(M, int)>;",
			"  int n;",
			"  FX fx;",
			"  FA fa;",
			"  FM fm;",
			"  FP fp;",
			"  const X ex;",
			"  const M em;",
			"  vector<X> dat;",
			"  vector<M> lazy;",
			"  SegTreeLazyProportional(int n_, FX fx_, FA fa_, FM fm_, FP fp_, X ex_, M em_)",
			"      : n(),",
			"        fx(fx_),",
			"        fa(fa_),",
			"        fm(fm_),",
			"        fp(fp_),",
			"        ex(ex_),",
			"        em(em_),",
			"        dat(n_ * 4, ex),",
			"        lazy(n_ * 4, em) {",
			"    int x = 1;",
			"    while (n_ > x) x *= 2;",
			"    n = x;",
			"  }",
			"",
			"  void set(int i, X x) { dat[i + n - 1] = x; }",
			"  void build() {",
			"    for (int k = n - 2; k >= 0; k--)",
			"      dat[k] = fx(dat[2 * k + 1], dat[2 * k + 2]);",
			"  }",
			"",
			"  /* lazy eval */",
			"  void eval(int k, int len) {",
			"    if (lazy[k] == em) return;  // 更新するものが無ければ終了",
			"    if (k < n - 1) {            // 葉でなければ子に伝搬",
			"      lazy[k * 2 + 1] = fm(lazy[k * 2 + 1], lazy[k]);",
			"      lazy[k * 2 + 2] = fm(lazy[k * 2 + 2], lazy[k]);",
			"    }",
			"    // 自身を更新",
			"    dat[k] = fa(dat[k], fp(lazy[k], len));",
			"    lazy[k] = em;",
			"  }",
			"",
			"  void update(int a, int b, M x, int k, int l, int r) {",
			"    eval(k, r - l);",
			"    if (a <= l && r <= b) {  // 完全に内側の時",
			"      lazy[k] = fm(lazy[k], x);",
			"      eval(k, r - l);",
			"    } else if (a < r && l < b) {                   // 一部区間が被る時",
			"      update(a, b, x, k * 2 + 1, l, (l + r) / 2);  // 左の子",
			"      update(a, b, x, k * 2 + 2, (l + r) / 2, r);  // 右の子",
			"      dat[k] = fx(dat[k * 2 + 1], dat[k * 2 + 2]);",
			"    }",
			"  }",
			"  void update(int a, int b, M x) { update(a, b, x, 0, 0, n); }",
			"",
			"  X query_sub(int a, int b, int k, int l, int r) {",
			"    eval(k, r - l);",
			"    if (r <= a || b <= l) {  // 完全に外側の時",
			"      return ex;",
			"    } else if (a <= l && r <= b) {  // 完全に内側の時",
			"      return dat[k];",
			"    } else {  // 一部区間が被る時",
			"      X vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);",
			"      X vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);",
			"      return fx(vl, vr);",
			"    }",
			"  }",
			"  X query(int a, int b) { return query_sub(a, b, 0, 0, n); }",
			"};",
			""
		],
		"description": "遅延セグ木（抽象化）"
	},
	"SegTree-template": {
		"prefix": "segment",
		"body": [
			"using X = int;",
			"using M = int;",
			"auto fx = [](X x1, X x2) -> X { return x1 + x2; };",
			"auto fa = [](X x, M m) -> X { return x; };",
			"auto fm = [](M m1, M m2) -> M { return m2; };",
			"auto fp = [](M m, int n) -> M { return m; };",
			"X ex = 0;",
			"M em = inf;",
			"SegTreeLazyProportional<X, M> seg(n, fx, fa, fm, fp, ex, em);"
		],
		"description": "SegTree-template"
	},
	"Lowest Common Ancestor": {
		"prefix": "lca",
		"body": [
			"template <class T>",
			"struct SegmentTree {",
			"  using F = function<T(T, T)>;",
			"  F f;",
			"  T inf;",
			"  int n;",
			"  vector<T> node;",
			"",
			"  SegmentTree() {}",
			"  SegmentTree(vector<T> v, T inf, F f) : inf(inf), f(f) {",
			"    n = 1;",
			"    while (n < v.size()) n *= 2;",
			"    node.resize(2 * n - 1, inf);",
			"    for (int i = 0; i < v.size(); i++) node[i + n - 1] = v[i];",
			"    for (int i = n - 2; i >= 0; i--)",
			"      node[i] = f(node[2 * i + 1], node[2 * i + 2]);",
			"  }",
			"",
			"  void update(int k, T val) {",
			"    k += n - 1;",
			"    node[k] = val;",
			"    while (k > 0) {",
			"      k = (k - 1) / 2;",
			"      node[k] = f(node[2 * k + 1], node[2 * k + 2]);",
			"    }",
			"  }",
			"",
			"  void add(int k, T val) {",
			"    k += n - 1;",
			"    node[k] += val;",
			"    while (k > 0) {",
			"      k = (k - 1) / 2;",
			"      node[k] = f(node[2 * k + 1], node[2 * k + 2]);",
			"    }",
			"  }",
			"",
			"  //区間[a, b)の値を返す",
			"  T operator[](int x) { return get(x, x + 1); }",
			"  T get(int a, int b) { return get(a, b, 0, 0, n); }",
			"  T get(int a, int b, int k, int l, int r) {",
			"    if (r <= a || b <= l) return inf;",
			"    if (a <= l && r <= b) return node[k];",
			"    T vl = get(a, b, 2 * k + 1, l, (l + r) / 2);",
			"    T vr = get(a, b, 2 * k + 2, (l + r) / 2, r);",
			"    return f(vl, vr);",
			"  }",
			"",
			"  void print(int n) {",
			"    for (int i = 0; i < n; i++) {",
			"      cout << get(i, i + 1) << \" \";",
			"    }",
			"    cout << endl;",
			"  }",
			"};",
			"",
			"struct edge {",
			"  int to, cost;",
			"};",
			"struct LCA {",
			"  vector<int> euler;  //オイラー路の訪問順",
			"  vector<int> dist;   //根からの距離",
			"  vector<int> left;   //初めて頂点iに訪れたk",
			"  vector<int> right;  //最後に頂点iに訪れたk",
			"  SegmentTree<P> seg;  //{根からの距離, k}",
			"  vector<vector<edge>> g;",
			"",
			"  LCA(vector<vector<edge>> g, int s = 0) : g(g) {",
			"    int n = g.size(), k = 0;",
			"    euler.resize(2 * n - 1);",
			"    dist.resize(2 * n - 1);",
			"    left.resize(n), right.resize(n);",
			"    dfs(s, -1, 0, k);",
			"    vector<P> v;",
			"    for (int i = 0; i < dist.size(); i++) {",
			"      v.emplace_back(dist[i], euler[i]);",
			"    }",
			"    seg = SegmentTree<P>(v, P(inf, inf), [&](P x, P y) { return min(x, y); });",
			"  }",
			"",
			"  //オイラー路",
			"  void dfs(int u, int par, int cost, int &k) {",
			"    left[u] = right[u] = k;",
			"    euler[k] = u;",
			"    dist[k++] = cost;",
			"    for (auto e : g[u]) {",
			"      if (e.to == par) continue;",
			"      dfs(e.to, u, cost + e.cost, k);",
			"      right[u] = k;",
			"      euler[k] = u;",
			"      dist[k++] = cost;",
			"    }",
			"  }",
			"",
			"  //共通祖先",
			"  int getnode(int u, int v) {",
			"    if (left[u] > left[v]) swap(u, v);",
			"    return seg.get(left[u], left[v] + 1).second;",
			"  }",
			"",
			"  // uとvの最短距離",
			"  int getdist(int u, int v) {",
			"    return dist[left[u]] + dist[left[v]] - dist[getnode(u, v)] * 2;",
			"  }",
			"};",
			""
		],
		"description": "Lowest Common Ancestor"
	},
	"Matrix": {
		"prefix": "matrix",
		"body": [
			"template< class T >",
			"struct Matrix {",
			"  vector< vector< T > > A;",
			"",
			"  Matrix() {}",
			"",
			"  Matrix(size_t n, size_t m) : A(n, vector< T >(m, 0)) {}",
			"",
			"  Matrix(size_t n) : A(n, vector< T >(n, 0)) {};",
			"",
			"  size_t height() const {",
			"    return (A.size());",
			"  }",
			"",
			"  size_t width() const {",
			"    return (A[0].size());",
			"  }",
			"",
			"  inline const vector< T > &operator[](int k) const {",
			"    return (A.at(k));",
			"  }",
			"",
			"  inline vector< T > &operator[](int k) {",
			"    return (A.at(k));",
			"  }",
			"",
			"  static Matrix I(size_t n) {",
			"    Matrix mat(n);",
			"    for(int i = 0; i < n; i++) mat[i][i] = 1;",
			"    return (mat);",
			"  }",
			"",
			"  Matrix &operator+=(const Matrix &B) {",
			"    size_t n = height(), m = width();",
			"    assert(n == B.height() && m == B.width());",
			"    for(int i = 0; i < n; i++)",
			"      for(int j = 0; j < m; j++)",
			"        (*this)[i][j] += B[i][j];",
			"    return (*this);",
			"  }",
			"",
			"  Matrix &operator-=(const Matrix &B) {",
			"    size_t n = height(), m = width();",
			"    assert(n == B.height() && m == B.width());",
			"    for(int i = 0; i < n; i++)",
			"      for(int j = 0; j < m; j++)",
			"        (*this)[i][j] -= B[i][j];",
			"    return (*this);",
			"  }",
			"",
			"  Matrix &operator*=(const Matrix &B) {",
			"    size_t n = height(), m = B.width(), p = width();",
			"    assert(p == B.height());",
			"    vector< vector< T > > C(n, vector< T >(m, 0));",
			"    for(int i = 0; i < n; i++)",
			"      for(int j = 0; j < m; j++)",
			"        for(int k = 0; k < p; k++)",
			"          C[i][j] = (C[i][j] + (*this)[i][k] * B[k][j]);",
			"    A.swap(C);",
			"    return (*this);",
			"  }",
			"",
			"  Matrix &operator^=(long long k) {",
			"    Matrix B = Matrix::I(height());",
			"    while(k > 0) {",
			"      if(k & 1) B *= *this;",
			"      *this *= *this;",
			"      k >>= 1LL;",
			"    }",
			"    A.swap(B.A);",
			"    return (*this);",
			"  }",
			"",
			"  Matrix operator+(const Matrix &B) const {",
			"    return (Matrix(*this) += B);",
			"  }",
			"",
			"  Matrix operator-(const Matrix &B) const {",
			"    return (Matrix(*this) -= B);",
			"  }",
			"",
			"  Matrix operator*(const Matrix &B) const {",
			"    return (Matrix(*this) *= B);",
			"  }",
			"",
			"  Matrix operator^(const long long k) const {",
			"    return (Matrix(*this) ^= k);",
			"  }",
			"",
			"  friend ostream &operator<<(ostream &os, Matrix &p) {",
			"    size_t n = p.height(), m = p.width();",
			"    for(int i = 0; i < n; i++) {",
			"      os << \"[\";",
			"      for(int j = 0; j < m; j++) {",
			"        os << p[i][j] << (j + 1 == m ? \"]\\n\" : \",\");",
			"      }",
			"    }",
			"    return (os);",
			"  }",
			"",
			"",
			"  T determinant() {",
			"    Matrix B(*this);",
			"    assert(width() == height());",
			"    T ret = 1;",
			"    for(int i = 0; i < width(); i++) {",
			"      int idx = -1;",
			"      for(int j = i; j < width(); j++) {",
			"        if(B[j][i] != 0) idx = j;",
			"      }",
			"      if(idx == -1) return (0);",
			"      if(i != idx) {",
			"        ret *= -1;",
			"        swap(B[i], B[idx]);",
			"      }",
			"      ret *= B[i][i];",
			"      T vv = B[i][i];",
			"      for(int j = 0; j < width(); j++) {",
			"        B[i][j] /= vv;",
			"      }",
			"      for(int j = i + 1; j < width(); j++) {",
			"        T a = B[j][i];",
			"        for(int k = 0; k < width(); k++) {",
			"          B[j][k] -= B[i][k] * a;",
			"        }",
			"      }",
			"    }",
			"    return (ret);",
			"  }",
			"};"
		],
		"description": "Matrix"
	},
}