{
  // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
  // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
  // same ids are connected.
  "競プロ用template": {
    "prefix": "temp",
    "body": [
      "#include <bits/stdc++.h>",
      "#ifdef _DEBUG",
      "#include \"_DEBUG.hpp\"",
      "#endif",
      "#define int long long",
      "using namespace std;",
      "using P = pair<int, int>;",
      "const int inf = 2e18;",
      "const int mod = 1e9 + 7;",
      "",
      "template <typename T>",
      "istream &operator>>(istream &is, vector<T> &v) {",
      "  for (T &in : v) is >> in;",
      "  return is;",
      "}",
      "",
      "template <class T>",
      "vector<T> make_vec(size_t a) {",
      "  return vector<T>(a);",
      "}",
      "",
      "template <class T, class... Ts>",
      "auto make_vec(size_t a, Ts... ts) {",
      "  return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));",
      "}",
      "",
      "template <class T, class V>",
      "typename enable_if<is_class<T>::value == 0>::type fill(T &t, const V &v) {",
      "  t = v;",
      "}",
      "",
      "template <class T, class V>",
      "typename enable_if<is_class<T>::value != 0>::type fill(T &t, const V &v) {",
      "  for (auto &e : t) fill(e, v);",
      "}",
      "",
      "signed main() {",
      "  ",
      "  $0",
      "",
      "  return 0;",
      "}"
    ],
    "description": "競プロ用template"
  },
  "IoSetup": {
    "prefix": "iosetup",
    "body": [
      "struct IoSetup {",
      "  IoSetup() {",
      "    cin.tie(nullptr);",
      "    ios::sync_with_stdio(false);",
      "    cout << fixed << setprecision(10);",
      "    cerr << fixed << setprecision(10);",
      "  }",
      "} iosetup;",
      "#define endl '\\n'",
    ],
    "description": "IoSetup"
  },
  "comment": {
    "prefix": "commet",
    "body": [
      "/* ----- $1 ----- */$0"
    ],
    "description": "comment"
  },
  "for(i, n)": {
    "prefix": "for",
    "body": [
      "for (int ${1:i} = 0; ${1:i} < ${2:n}; ${1:i}++) {",
      "  $0",
      "}"
    ],
    "description": "for"
  },
  "dx dy": {
    "prefix": "for",
    "body": [
      "int dy[4] = {1, 0, -1, 0}, dx[4] = {0, 1, 0, -1};",
      "for (int i = 0; i < 4; i++) {",
      "  int ny = y + dy[i];",
      "  int nx = x + dx[i];",
      "  if (ny < 0 || h <= ny || nx < 0 || w <= nx) continue;",
      "}"
    ],
    "description": "dx dy"
  },
  "printf(double)": {
    "prefix": "printf",
    "body": [
      "printf(\"%.9f\\n\", $1);"
    ],
    "description": "printf(double)"
  },
  "v.begin(), v.end()": {
    "prefix": "all",
    "body": [
      "$1.begin(), $1.end()$0"
    ],
    "description": "v.begin(), v.end()"
  },
  "push_back": {
    "prefix": "push",
    "body": [
      "push_back($0)"
    ],
    "description": "push_back"
  },
  "erase_vector": {
    "prefix": "erase",
    "body": [
      "$1.erase(unique($1.begin(),$1.end()),$1.end());"
    ],
    "description": "erase_vector"
  },
  "priority_queue": {
    "prefix": "priority",
    "body": [
      "priority_queue<$1, vector<$1>, greater<$1>> q;$0"
    ],
    "description": "priority_queue"
  },
  "operator(構造体用)": {
    "prefix": "operator",
    "body": [
      "bool operator<(const ${1:Data}& p) const {",
      "  return ${2:cost} < p.${2:cost};",
      "}",
      "bool operator>(const ${1:Data}& p) const {",
      "  return ${2:cost} > p.${2:cost};",
      "}"
    ],
    "description": "operator(構造体用)"
  },
  "binary_search": {
    "prefix": "binary_search",
    "body": [
      "int left = -1, right = n;",
      "while(right - left > 1){",
      "  int mid = (left + right) / 2;",
      "  ( ? right : left) = mid;",
      "}"
    ],
    "description": "binary_search"
  },
  "__builtin_popcountll": {
    "prefix": "popcount",
    "body": [
      "__builtin_popcountll($0)"
    ],
    "description": "__builtin_popcountll()"
  },
  "dfs": {
    "prefix": "dfs",
    "body": [
      "auto dfs = [&](auto&& dfs, int u, int par)->void{",
      "  for(int v : g[u]){",
      "    if(v == par) continue;",
      "    dfs(dfs, v, u);",
      "  }",
      "};"
    ],
    "description": "dfs"
  },
  "Combination": {
    "prefix": "comb",
    "body": [
      "struct Combination{",
      "  vector<int> fact; //　fact[i] = iの階乗",
      "  Combination(int n) : fact(n+1){",
      "    fact[0] = fact[1] = 1;",
      "    for(int i = 2; i <= n; i++){",
      "      fact[i] = fact[i-1] * i % MOD;",
      "    }",
      "  }",
      "",
      "  int nCr(int n, int r){ // nCr = n!/r!(n-r)!",
      "    if(n < r) return 0;",
      "    return fact[n] * inv(fact[r]*fact[n-r]%MOD) % MOD;",
      "  }",
      "",
      "  int inv(int n, int p = MOD-2){ // a/n ≡ a*n^(p-2) nとpは互いに素",
      "    int r = 1;",
      "    for(; p > 0; p >>= 1){",
      "      if(p & 1LL) r = r * n % MOD;",
      "      n = n * n % MOD;",
      "    }",
      "    return r; // r = n^p % MOD",
      "  }",
      "};"
    ],
    "description": "Combination"
  },
  "dikstra": {
    "prefix": "dikstra",
    "body": [
      "struct edge{ int to, cost; };",
      "vector<int> dikstra(vector<vector<edge>> G, int s){",
      "  using P = pair<int, int>;",
      "  priority_queue<P,vector<P>,greater<P>> q;",
      "  vector<int> d(G.size(), INF); //sからの最短距離",
      "  d[s] = 0;",
      "  q.push({0, s}); //{最短距離,頂点}",
      "",
      "  while(!q.empty()){",
      "    auto p = q.top(); q.pop();",
      "    int v = p.second;",
      "    if(d[v] < p.first) continue;",
      "    for(auto e : G[v]){",
      "      if(d[e.to] > d[v] + e.cost){",
      "        d[e.to] = d[v] + e.cost;",
      "        q.push(P(d[e.to], e.to));",
      "      }",
      "    }",
      "  }",
      "  return d;",
      "}"
    ],
    "description": "dikstra"
  },
  "mod_int": {
    "prefix": "mod",
    "body": [
      "template< int mod >",
      "struct ModInt {",
      "  int x;",
      "  ModInt() : x(0) {}",
      "  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}",
      "  ModInt &operator+=(const ModInt &p) {",
      "    if((x += p.x) >= mod) x -= mod;",
      "    return *this;",
      "  }",
      "  ModInt &operator-=(const ModInt &p) {",
      "    if((x += mod - p.x) >= mod) x -= mod;",
      "    return *this;",
      "  }",
      "  ModInt &operator*=(const ModInt &p) {",
      "    x = (int) (1LL * x * p.x % mod);",
      "    return *this;",
      "  }",
      "  ModInt &operator/=(const ModInt &p) {",
      "    *this *= p.inverse();",
      "    return *this;",
      "  }",
      "  ModInt operator-() const { return ModInt(-x); }",
      "  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }",
      "  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }",
      "  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }",
      "  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }",
      "  bool operator==(const ModInt &p) const { return x == p.x; }",
      "  bool operator!=(const ModInt &p) const { return x != p.x; }",
      "  ModInt inverse() const {",
      "    int a = x, b = mod, u = 1, v = 0, t;",
      "    while(b > 0) {",
      "      t = a / b;",
      "      swap(a -= t * b, b);",
      "      swap(u -= t * v, v);",
      "    }",
      "    return ModInt(u);",
      "  }",
      "  ModInt pow(int64_t n) const {",
      "    ModInt ret(1), mul(x);",
      "    while(n > 0) {",
      "      if(n & 1) ret *= mul;",
      "      mul *= mul;",
      "      n >>= 1;",
      "    }",
      "    return ret;",
      "  }",
      "  friend ostream &operator<<(ostream &os, const ModInt &p) {",
      "    return os << p.x;",
      "  }",
      "  friend istream &operator>>(istream &is, ModInt &a) {",
      "    int64_t t;",
      "    is >> t;",
      "    a = ModInt< mod >(t);",
      "    return (is);",
      "  }",
      "};",
      "using mint = ModInt< 1000000007 >;"
    ],
    "description": "mod_int"
  },
},


// {
//   "Template": {
//     "prefix": "temp",
//     "body": [
//       "#include <cmath>",
//       "#include <cstdio>",
//       "#include <cstdlib>",
//       "#include <cstring>",
//       "",
//       "#include <algorithm>",
//       "#include <bitset>",
//       "#include <complex>",
//       "#include <iostream>",
//       "#include <map>",
//       "#include <numeric>",
//       "#include <queue>",
//       "#include <set>",
//       "#include <stack>",
//       "#include <string>",
//       "#include <unordered_map>",
//       "#include <unordered_set>",
//       "#include <vector>",
//       "",
//       "#include <cassert>",
//       "#include <functional>",
//       "",
//       "typedef long long ll;",
//       "using namespace std;",
//       "",
//       "#ifndef LOCAL",
//       "#define debug(...) ;",
//       "#else",
//       "#define debug(...) cerr << __LINE__ << \" : \" << #__VA_ARGS__ << \" = \" << _tostr(__VA_ARGS__) << endl;",
//       "",
//       "template<typename T>",
//       "ostream &operator<<(ostream &out, const vector<T> &v);",
//       "",
//       "template<typename T1, typename T2>",
//       "ostream &operator<<(ostream &out, const pair<T1, T2> &p) {",
//       "  out << \"{\" << p.first << \", \" << p.second << \"}\";",
//       "  return out;",
//       "}",
//       "",
//       "template<typename T>",
//       "ostream &operator<<(ostream &out, const vector<T> &v) {",
//       "  out << '{';",
//       "  for (const T &item : v) out << item << \", \";",
//       "  out << \"\\b\\b}\";",
//       "  return out;",
//       "}",
//       "",
//       "void _tostr_rec(ostringstream &oss) {",
//       "  oss << \"\\b\\b \\b\";",
//       "}",
//       "",
//       "template<typename Head, typename... Tail>",
//       "void _tostr_rec(ostringstream &oss, Head &&head, Tail &&...tail) {",
//       "  oss << head << \", \";",
//       "  _tostr_rec(oss, forward<Tail>(tail)...);",
//       "}",
//       "",
//       "template<typename... T>",
//       "string _tostr(T &&...args) {",
//       "  ostringstream oss;",
//       "  int size = sizeof...(args);",
//       "  if (size > 1) oss << \"{\";",
//       "  _tostr_rec(oss, forward<T>(args)...);",
//       "  if (size > 1) oss << \"}\";",
//       "  return oss.str();",
//       "}",
//       "#endif",
//       "",
//       "#define mod 1000000007 //1e9+7(prime number)",
//       "#define INF 1000000000 //1e9",
//       "#define LLINF 2000000000000000000LL //2e18",
//       "#define SIZE 200010",
//       "",
//       "",
//       "int main() {",
//       "  return 0;",
//       "}"
//     ],
//     "description": "Template"
//   },
//   "Sign": {
//     "prefix": "sign",
//     "body": [
//       "int sign(ll x) {",
//       "  return (x > 0) - (x < 0);",
//       "}"
//     ],
//     "description": "Sign"
//   },
//   "GCD-LCM": {
//     "prefix": "gcdlcm",
//     "body": [
//       "// GCC __gcd(long long A, long long B)",
//       "",
//       "ll gcd(ll a, ll b) {",
//       "  if (a == 0) return b;",
//       "  return gcd(b % a, a);",
//       "}",
//       "",
//       "ll lcm(ll a, ll b) {",
//       "  return a / gcd(a, b) * b;",
//       "}"
//     ],
//     "description": "GCD-LCM"
//   },
//   "Extended GCD": {
//     "prefix": "extgcd",
//     "body": [
//       "// {a, {b, c}} : a = gcd(p, q) = bp + cq",
//       "pair<ll, pair<ll, ll>> ext_gcd(ll p, ll q) {",
//       "  if (q == 0) return {p, {1, 0}};",
//       "  auto r = ext_gcd(q, p % q);",
//       "  return {r.first, {r.second.second, r.second.first - p / q * r.second.second}};",
//       "}"
//     ],
//     "description": "Extended GCD"
//   },
//   "Divisor": {
//     "prefix": "divisor",
//     "body": [
//       "template<typename T>",
//       "vector<T> divisor(T n) {",
//       "  vector<T> res, res2;",
//       "  for (T i = 1; i * i <= n; i++) {",
//       "    if (n % i == 0) {",
//       "      res.push_back(i);",
//       "      if (i * i < n) res2.push_back(n / i);",
//       "    }",
//       "  }",
//       "",
//       "  reverse(res2.begin(), res2.end());",
//       "  res.insert(res.end(), res2.begin(), res2.end());",
//       "",
//       "  return res;",
//       "}"
//     ],
//     "description": "Divisor"
//   },
//   "Power": {
//     "prefix": "power",
//     "body": [
//       "ll power(ll k, ll n, int M) {",
//       "  ll res = 1;",
//       "  while (n > 0) {",
//       "    if (n & 1) res = res * k % M;",
//       "    k = k * k % M;",
//       "    n /= 2;",
//       "  }",
//       "  return res;",
//       "}"
//     ],
//     "description": "Power"
//   },
//   "Combination,Permutation": {
//     "prefix": "pch",
//     "body": [
//       "vector<ll> factmemo, factmemoInv;",
//       "ll factmemoMod = -1;",
//       "",
//       "ll factorial(int n, int M) {",
//       "  if (factmemoMod == M) return factmemo[n];",
//       "  if (n <= 1) return 1;",
//       "",
//       "  ll res = 1;",
//       "  for (int i = 1; i <= n; i++) res = res * i % M;",
//       "  return res;",
//       "}",
//       "",
//       "ll power(ll k, ll n, int M) {",
//       "  ll res = 1;",
//       "  while (n > 0) {",
//       "    if (n & 1) res = res * k % M;",
//       "    k = k * k % M;",
//       "    n /= 2;",
//       "  }",
//       "  return res;",
//       "}",
//       "",
//       "void initFactorial(int n, int M) {",
//       "  factmemo.assign(n + 1, 0);",
//       "  factmemoInv.assign(n + 1, 0);",
//       "  factmemoMod = M;",
//       "  factmemo[0] = 1;",
//       "  for (int i = 1; i <= n; i++) factmemo[i] = factmemo[i - 1] * i % M;",
//       "  factmemoInv[n] = power(factmemo[n], M - 2, M);",
//       "  for (int i = n; i > 0; i--) factmemoInv[i - 1] = factmemoInv[i] * i % M;",
//       "}",
//       "",
//       "//nCm nPm nHm (mod M)",
//       "",
//       "/*Combination*/",
//       "ll C(int n, int m, int M) {",
//       "  if (n < m) return 0;",
//       "  if (m == 0 || n == m) return 1;",
//       "",
//       "  if (factmemoMod == M)",
//       "    return factmemo[n] * factmemoInv[m] % M * factmemoInv[n - m] % M;",
//       "",
//       "  ll numer = factorial(n, M);",
//       "  ll denom = factorial(m, M) * factorial(n - m, M) % M;",
//       "",
//       "  denom = power((int)denom, M - 2, M);",
//       "",
//       "  return numer * denom % M;",
//       "}",
//       "/*Permutation*/",
//       "ll P(int n, int m, int M) {",
//       "  if (n < m) return 0;",
//       "  if (m == 0) return 1;",
//       "",
//       "  if (factmemoMod == M)",
//       "    return factmemo[n] * factmemoInv[n - m] % M;",
//       "",
//       "  ll numer = factorial(n, M);",
//       "  ll denom = factorial(n - m, M);",
//       "",
//       "  denom = power((int)denom, M - 2, M);",
//       "",
//       "  return numer * denom % M;",
//       "}",
//       "/*Combination with Repetitions*/",
//       "ll H(int n, int m, int M) {",
//       "  if (n == 0 && m == 0) return 1;",
//       "  return C(n + m - 1, m, M);",
//       "}"
//     ],
//     "description": "Combination,Permutation"
//   },
//   "Permutation Converter": {
//     "prefix": "permutation",
//     "body": [
//       "/* Permutation <-> ID */",
//       "// {0,1,2} <=> 0, {0,2,1} <=> 1, {2, 1, 0} <=> 5",
//       "",
//       "namespace PermutationConverter {",
//       "  const int MAX_DATASIZE = 20;",
//       "",
//       "  ll encode(int N, int *data) {",
//       "    bool used[MAX_DATASIZE] = {};",
//       "    ll id = 0, t = 1;",
//       "",
//       "    for (int i = 1; i <= N; i++) t *= i;",
//       "",
//       "    for (int i = 0; i < N; i++) {",
//       "      t /= (N - i);",
//       "      used[data[i]] = true;",
//       "      id += count(used, used + data[i], false) * t;",
//       "    }",
//       "",
//       "    return id;",
//       "  }",
//       "",
//       "  void decode(int N, ll id, int *data) {",
//       "    bool used[MAX_DATASIZE] = {};",
//       "    ll t = 1;",
//       "",
//       "    for (int i = 1; i <= N; i++) t *= i;",
//       "",
//       "    for (int i = 0; i < N; i++) {",
//       "      t /= (N - i);",
//       "",
//       "      int s = id / t;",
//       "      for (int j = 0;; j++) {",
//       "        if (!used[j] && s == 0) {",
//       "          data[i] = j;",
//       "          used[j] = true;",
//       "          break;",
//       "        }",
//       "        s -= !used[j];",
//       "      }",
//       "",
//       "      id %= t;",
//       "    }",
//       "  }",
//       "};"
//     ],
//     "description": "Permutation Converter"
//   },
//   "Sieve of Eratosthenes": {
//     "prefix": "eratos",
//     "body": [
//       "vector<bool> isPrime;",
//       "",
//       "void Eratosthenes(int N) {",
//       "  isPrime.assign(N + 1, true);",
//       "  isPrime[0] = isPrime[1] = false;",
//       "",
//       "  for (int i = 2; i * i <= N; i++)",
//       "    if (isPrime[i])",
//       "      for (int j = i; i * j <= N; j++)",
//       "        isPrime[i * j] = false;",
//       "}"
//     ],
//     "description": "Sieve of Eratosthenes"
//   },
//   "Miller-Rabin Primality Test": {
//     "prefix": "millerrabin",
//     "body": [
//       "/* \u30df\u30e9\u30fc-\u30e9\u30d3\u30f3\u7d20\u6570\u5224\u5b9a\u6cd5 */",
//       "",
//       "namespace MillerRabin {",
//       "  typedef __int128_t Int;",
//       "  Int power(Int k, Int n, ll M) {",
//       "    if (n == 0) return 1;",
//       "    if (n == 1) return k % M;",
//       "",
//       "    Int res = power(k, n / 2, M);",
//       "    res = res * res % M;",
//       "    return n % 2 ? res % M * k % M : res;",
//       "  }",
//       "",
//       "  bool isPrime(ll x) {",
//       "    int a[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, -1}; // x < 2^64",
//       "    //int a[] = {2, 7, 61, -1}; // x < 2^32",
//       "    if (x == 2) return true;",
//       "    if (x <= 1 || x % 2 == 0) return false;",
//       "    Int d = x - 1;",
//       "    int s = 0;",
//       "    for (; d % 2 == 0; s++) d >>= 1;",
//       "    for (int i = 0; a[i] != -1 && a[i] < x; i++) {",
//       "      Int y = power(a[i], d, x);",
//       "      if (y == 1) continue;",
//       "      for (int j = 0; j < s - 1 && y != x - 1; j++) y = (y * y) % x;",
//       "      if (y != x - 1) return false;",
//       "    }",
//       "    return true;",
//       "  }",
//       "};"
//     ],
//     "description": "Miller-Rabin Primality Test"
//   },
//   "Euler\\'s Phi Function": {
//     "prefix": "eulerphi",
//     "body": [
//       "/* \u30aa\u30a4\u30e9\u30fc\u306e\u03a6\u95a2\u6570 */",
//       "// n\u3068\u4e92\u3044\u306b\u7d20\u306an\u4ee5\u4e0b\u306e\u6570\u306e\u500b\u6570",
//       "",
//       "// power(a, phi(n)-1) * a = 1",
//       "// (gcd(a, n) = 1)",
//       "",
//       "ll eulerPhi(ll n) {",
//       "  if (n <= 0) return 0;",
//       "  ll res = n;",
//       "  for (int i = 2; i * i <= n; i++) {",
//       "    if (n % i == 0) {",
//       "      res -= res / i;",
//       "      while (n % i == 0) n /= i;",
//       "    }",
//       "  }",
//       "  if (n > 1) res -= res / n;",
//       "  return res;",
//       "}",
//       "",
//       "vector<int> eulerPhiTable(int n) {",
//       "  vector<int> phi(n + 1);",
//       "  iota(phi.begin(), phi.end(), 0);",
//       "",
//       "  for (int i = 2; i <= n; i++)",
//       "    if (phi[i] == i)",
//       "      for (int j = 1; j * i <= n; j++)",
//       "        phi[i * j] -= phi[i * j] / i;",
//       "",
//       "  return phi;",
//       "}"
//     ],
//     "description": "Euler\\'s Phi Function"
//   },
//   "Primitive Root": {
//     "prefix": "primitiveroot",
//     "body": [
//       "ll getPrimitiveRoot(ll P) {",
//       "  // assert(isPrime(P));",
//       "  if (P == 2) return 1;",
//       "  ll p = P - 1;",
//       "  vector<ll> a;",
//       "",
//       "  for (int i = 2; i * i <= p; i++) {",
//       "    if (p % i == 0) a.push_back(i);",
//       "    while (p % i == 0) p /= i;",
//       "  }",
//       "  if (p > 1) a.push_back(p);",
//       "",
//       "  while (1) {",
//       "    bool ok = true;",
//       "    ll r = rand() % (P - 2) + 2;",
//       "    for (auto q : a)",
//       "      ok &= power(r, (P - 1) / q, P) != 1;",
//       "    if (ok) return r;",
//       "  }",
//       "}"
//     ],
//     "description": "Primitive Root"
//   },
//   "Simultaneous Equation": {
//     "prefix": "gauss",
//     "body": [
//       "/* \u9023\u7acb\u4e00\u6b21\u65b9\u7a0b\u5f0f (Gauss\u6cd5) */",
//       "/*",
//       "3x + 2y = 7",
//       "2x + 5y = 12",
//       "double a[2][2]= {{3, 2},{2,5}};",
//       "double b[2]={ 7, 12};",
//       "",
//       "run -> b[2] = {1, 2}",
//       "*/",
//       "",
//       "#define gaussN 2",
//       "",
//       "void Gauss(double a[gaussN][gaussN], int b[gaussN]) {",
//       "  /* a, b\u306e\u4e2d\u8eab\u306f\u7834\u58ca\u3055\u308c\u308b */",
//       "  int n = gaussN;",
//       "",
//       "  for (int k = 0; k < n; k++) {",
//       "    for (int j = k + 1; j < n; j++)",
//       "      a[k][j] /= a[k][k];",
//       "    b[k] /= a[k][k];",
//       "",
//       "    for (int i = k + 1; i < n; i++) {",
//       "      for (int j = k + 1; j < n; j++)",
//       "        a[i][j] -= a[k][j] * a[i][k];",
//       "      b[i] -= b[k] * a[i][k];",
//       "    }",
//       "  }",
//       "",
//       "  for (int k = n - 2; k >= 0; k--)",
//       "    for (int j = k + 1; j < n; j++)",
//       "      b[k] -= a[k][j] * b[j];",
//       "}"
//     ],
//     "description": "Simultaneous Equation"
//   },
//   "Fast Zeta Transform": {
//     "prefix": "fzt",
//     "body": [
//       "/* FastZetaTransform */",
//       "",
//       "// a[1001] = a[1001] + a[1011] + a[1101] + a[1111];",
//       "",
//       "template<typename T>",
//       "void FZT(int n, T *a) {",
//       "  for (int i = 0; i < n; i++)",
//       "    for (int j = 0; j < (1 << n); j++)",
//       "      if (!(j & (1 << i))) a[j] += a[j | (1 << i)]; //\u7dcf\u548c",
//       "}",
//       "",
//       "// a[1001] = a[1001] + a[1000] + a[0001] + a[0000];",
//       "",
//       "template<typename T>",
//       "void FZT2(int n, T *a) {",
//       "  for (int i = 0; i < n; i++)",
//       "    for (int j = 0; j < (1 << n); j++)",
//       "      if (j & (1 << i)) a[j] += a[j ^ (1 << i)]; //\u7dcf\u548c",
//       "}"
//     ],
//     "description": "Fast Zeta Transform"
//   },
//   "Fast Fourier Transform": {
//     "prefix": "fft",
//     "body": [
//       "/* Fast Fourier Transform */",
//       "",
//       "namespace FFT {",
//       "  using C = complex<double>;",
//       "",
//       "  void DFT(vector<C> &a, bool rev = false) {",
//       "    int N = a.size();",
//       "    //const double M_PI = acos(-1);",
//       "",
//       "    for (int i = 0, j = 1; j + 1 < N; j++) {",
//       "      for (int k = N >> 1; k > (i ^= k); k >>= 1)",
//       "        ;",
//       "      if (i > j) swap(a[i], a[j]);",
//       "    }",
//       "",
//       "    for (int i = 1; i < N; i *= 2) {",
//       "      for (int j = 0; j < i; j++) {",
//       "        C w = polar(1.0, M_PI / i * (rev ? -1 : 1) * j);",
//       "        for (int k = 0; k < N; k += i * 2) {",
//       "          C s = a[j + k], t = a[j + k + i] * w;",
//       "          a[j + k + 0] = s + t;",
//       "          a[j + k + i] = s - t;",
//       "        }",
//       "      }",
//       "    }",
//       "",
//       "    if (rev)",
//       "      for (C &v : a) v /= N;",
//       "  }",
//       "",
//       "  vector<ll> conv(const vector<int> &a, const vector<int> &b) {",
//       "    int s = 1, t = a.size() + b.size() - 1;",
//       "    while (s < t) s *= 2;",
//       "",
//       "    vector<C> F(s), G(s);",
//       "    for (int i = 0; i < (int)a.size(); i++) F[i] = a[i];",
//       "    for (int i = 0; i < (int)b.size(); i++) G[i] = b[i];",
//       "    DFT(F);",
//       "    DFT(G);",
//       "",
//       "    for (int i = 0; i < s; i++) F[i] *= G[i];",
//       "    DFT(F, true);",
//       "",
//       "    vector<ll> res(t);",
//       "    for (int i = 0; i < t; i++) res[i] = F[i].real() + 0.5; //round",
//       "    return res;",
//       "  }",
//       "};"
//     ],
//     "description": "Fast Fourier Transform"
//   },
//   "Number Theoretic Transform": {
//     "prefix": "ntt",
//     "body": [
//       "/* Number Theoretic Transform */",
//       "",
//       "namespace NTT {",
//       "  void DFT(int m, int root, vector<int> &a, bool rev = false) {",
//       "    int N = a.size();",
//       "",
//       "    for (int i = 0, j = 1; j + 1 < N; j++) {",
//       "      for (int k = N >> 1; k > (i ^= k); k >>= 1)",
//       "        ;",
//       "      if (i > j) swap(a[i], a[j]);",
//       "    }",
//       "",
//       "    int g = power(root, (m - 1) / N, m);",
//       "    if (rev) g = power(g, m - 2, m);",
//       "",
//       "    for (int i = 1; i < N; i *= 2) {",
//       "      int base = power(g, N / i / 2, m);",
//       "      ll w = 1;",
//       "      for (int j = 0; j < i; j++) {",
//       "        for (int k = 0; k < N; k += i * 2) {",
//       "          int s = a[j + k], t = a[j + k + i] * w % m;",
//       "          a[j + k + 0] = (s + t) % m;",
//       "          a[j + k + i] = (s - t + m) % m;",
//       "        }",
//       "        w = w * base % m;",
//       "      }",
//       "    }",
//       "",
//       "    if (rev) {",
//       "      ll tmp = power(N, m - 2, m);",
//       "      for (int &v : a) v = v * tmp % m;",
//       "    }",
//       "  }",
//       "",
//       "  // (469762049, 3), (924844033, 5), (998244353, 3), (1012924417, 5)",
//       "",
//       "  vector<int> conv(int _mod, int root, const vector<int> &a, const vector<int> &b) {",
//       "    int s = 1, t = a.size() + b.size() - 1;",
//       "    while (s < t) s *= 2;",
//       "",
//       "    vector<int> F(s), G(s);",
//       "    for (int i = 0; i < (int)a.size(); i++) F[i] = a[i];",
//       "    for (int i = 0; i < (int)b.size(); i++) G[i] = b[i];",
//       "    DFT(_mod, root, F);",
//       "    DFT(_mod, root, G);",
//       "",
//       "    for (int i = 0; i < s; i++) F[i] = (ll)F[i] * G[i] % _mod;",
//       "    DFT(_mod, root, F, true);",
//       "",
//       "    return F;",
//       "  }",
//       "};"
//     ],
//     "description": "Number Theoretic Transform"
//   },
//   "Lagrange Interpolation": {
//     "prefix": "lagrange",
//     "body": [
//       "/* \u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u88dc\u9593 */",
//       "",
//       "// y[i] = f(x[i]) mod P",
//       "// 0 <= x[i], y[i] < P",
//       "// f = sum(res[i] * x^i)",
//       "vector<int> lagrangeInterpolation(const vector<int> &x, const vector<int> &y, int P) {",
//       "  int N = x.size();",
//       "  vector<ll> Q(N + 1);",
//       "  vector<int> res(N);",
//       "",
//       "  Q[0] = 1;",
//       "  for (int i = 0; i < N; i++) {",
//       "    for (int j = i; j >= 0; j--) {",
//       "      Q[j + 1] = (Q[j + 1] - Q[j] + P) % P;",
//       "      Q[j] = Q[j] * x[i] % P;",
//       "    }",
//       "  }",
//       "",
//       "  for (int i = 0; i < N; i++) {",
//       "    ll ainv = power(x[i], P - 2, P), c = 1;",
//       "",
//       "    for (int j = 0; j < N; j++)",
//       "      if (i != j) c = c * (x[j] - x[i] + P) % P;",
//       "",
//       "    ll prev = Q[0], p = (ll)y[i] * power(c, P - 2, P) % P;",
//       "    for (int j = 0; j < N; j++) {",
//       "      ll v = x[i] ? prev * ainv % P : P - Q[j + 1]; //: Q[j+1] * inv(-1) % P;",
//       "      res[j] = (v * p + res[j]) % P;",
//       "      prev = (Q[j + 1] + v) % P;",
//       "    }",
//       "  }",
//       "",
//       "  return res;",
//       "}",
//       "",
//       "// y[i] = f(x[i]) mod P",
//       "// 0 <= y[i], T < P",
//       "// res = f(T)",
//       "int lagrangeInterpolation(const vector<int> &y, int T, int P) {",
//       "  int N = y.size();",
//       "  ll val = T, res = 0, fact = 1;",
//       "",
//       "  for (int i = 1; i < N; i++) {",
//       "    fact = fact * i % P;",
//       "    val = (val * (T - i + P)) % P;",
//       "  }",
//       "  fact = power(fact, P - 2, P);",
//       "",
//       "  for (int i = 0; i < N; i++) {",
//       "    ll tmp = y[i] * val % P * power(T - i, P - 2, P) % P * fact % P;",
//       "    fact = fact * (N - i - 1) % P * power(i + 1, P - 2, P) % P;",
//       "    res += tmp * ((N - i) % 2 ? 1 : -1);",
//       "  }",
//       "",
//       "  return (res % P + P) % P;",
//       "}"
//     ],
//     "description": "Lagrange Interpolation"
//   },
//   "Chinese Remainder Theorem": {
//     "prefix": "chinese",
//     "body": [
//       "/* \u4e2d\u56fd\u5270\u4f59\u5b9a\u7406 */",
//       "",
//       "pair<ll, ll> CRT(ll a1, ll m1, ll a2, ll m2) {",
//       "  auto eg = ext_gcd(m1, m2);",
//       "  ll d = eg.first;",
//       "  if ((a2 - a1) % d) return {0, -1};",
//       "  ll m = m1 / d * m2;",
//       "  ll r = ((a1 + m1 * ((__int128_t)(a2 - a1) / d * eg.second.first % (m2 / d))) % m + m) % m;",
//       "  return {r, m};",
//       "}"
//     ],
//     "description": "Chinese Remainder Theorem"
//   },
//   "All the Subsets": {
//     "prefix": "subsets",
//     "body": [
//       "// 0101 => {0101, 0100, 0001}",
//       "for (int i = mask; i > 0; i = (i - 1) & mask) {}",
//       "",
//       "// 0101 => {0101, 0100, 0001, 0000}",
//       "for (int i = mask;; i = (i - 1) & mask) {",
//       "  //do something",
//       "  if (i == 0) break;",
//       "}",
//       "",
//       "// 0101 => {0101, 1101, 0111, 1111}",
//       "for (int i = mask; i < (1 << n); i = (i + 1) | mask) {}"
//     ],
//     "description": "All the Subsets"
//   },
//   "Simple Segment Tree": {
//     "prefix": "simpleseg",
//     "body": [
//       "/* SimpleSegTree(0-index) */",
//       "",
//       "template<typename Type = int>",
//       "struct SimpleSegTree {",
//       "  int segn2;",
//       "  Type initVal;",
//       "  vector<Type> data;",
//       "",
//       "  virtual Type merge(Type a, Type b) = 0;",
//       "",
//       "  SimpleSegTree(int n, Type initVal): initVal(initVal) {",
//       "    for (segn2 = 1; segn2 < n; segn2 *= 2)",
//       "      ;",
//       "    data.assign(segn2 * 2, initVal);",
//       "  }",
//       "",
//       "  Type query(int a, int b, int l = 0, int r = -1, int k = 0) {",
//       "    if (r == -1) r = segn2;",
//       "    if (a <= l && r <= b) return data[k];",
//       "    if (r <= a || b <= l) return initVal;",
//       "    return merge(query(a, b, l, (l + r) / 2, k * 2 + 1), query(a, b, (l + r) / 2, r, k * 2 + 2));",
//       "  }",
//       "",
//       "  //set kth number x",
//       "  void set(int k, Type x) {",
//       "    k += segn2 - 1;",
//       "    data[k] = x;",
//       "    while (k > 0) {",
//       "      k = (k - 1) / 2;",
//       "      data[k] = merge(data[k * 2 + 1], data[k * 2 + 2]);",
//       "    }",
//       "  }",
//       "};",
//       "",
//       "",
//       "template<typename Type = int>",
//       "struct RangeMinimumQuery final: SimpleSegTree<Type> {",
//       "  RangeMinimumQuery(int n, Type initVal = INF): SimpleSegTree<Type>(n, initVal) {}",
//       "  Type merge(Type a, Type b) {",
//       "    return min(a, b);",
//       "  }",
//       "};",
//       "",
//       "template<typename Type = int>",
//       "struct RangeMaximumQuery final: SimpleSegTree<Type> {",
//       "  RangeMaximumQuery(int n, Type initVal = -INF): SimpleSegTree<Type>(n, initVal) {}",
//       "  Type merge(Type a, Type b) {",
//       "    return max(a, b);",
//       "  }",
//       "};",
//       "",
//       "template<typename Type = int>",
//       "struct RangeSumQuery final: SimpleSegTree<Type> {",
//       "  RangeSumQuery(int n, Type initVal = 0): SimpleSegTree<Type>(n, initVal) {}",
//       "  Type merge(Type a, Type b) {",
//       "    return a + b;",
//       "  }",
//       "};"
//     ],
//     "description": "Simple Segment Tree"
//   },
//   "SegmentTree(RangeSum,RangeAdd)": {
//     "prefix": "segtree",
//     "body": [
//       "/* SegmentTree(Sum) */",
//       "//0-index",
//       "",
//       "template<typename Type = int>",
//       "struct SegTree {",
//       "  int segn2;",
//       "  Type inf;",
//       "  vector<Type> data, s_data;",
//       "",
//       "  SegTree(int n) {",
//       "    for (segn2 = 1; segn2 < n; segn2 *= 2)",
//       "      ;",
//       "",
//       "    data.assign(segn2 * 2, 0);",
//       "    s_data.assign(segn2 * 2, 0);",
//       "  }",
//       "",
//       "  //get sum of [a, b)",
//       "  Type query(int a, int b, int l = 0, int r = -1, int k = 0) {",
//       "    if (r == -1) r = segn2;",
//       "    if (r <= a || b <= l) return 0;",
//       "    if (a <= l && r <= b) return data[k] + s_data[k] * (r - l);",
//       "",
//       "    return (min(r, b) - max(l, a)) * s_data[k] +",
//       "           query(a, b, l, (l + r) / 2, k * 2 + 1) + query(a, b, (l + r) / 2, r, k * 2 + 2);",
//       "  }",
//       "",
//       "  //add x to [a, b)",
//       "  Type add(int a, int b, Type x, int l = 0, int r = -1, int k = 0) {",
//       "    if (r == -1) r = segn2;",
//       "",
//       "    if (a <= l && r <= b)",
//       "      s_data[k] += x;",
//       "    else if (a < r && l < b)",
//       "      data[k] = add(a, b, x, l, (l + r) / 2, k * 2 + 1) + add(a, b, x, (l + r) / 2, r, k * 2 + 2);",
//       "",
//       "    return data[k] + s_data[k] * (r - l);",
//       "  }",
//       "};"
//     ],
//     "description": "SegmentTree(RangeSum,RangeAdd)"
//   },
//   "Starry Sky Tree": {
//     "prefix": "starrysky",
//     "body": [
//       "/* Starry Sky Tree */",
//       "//0-index",
//       "",
//       "template<typename Type = int>",
//       "struct StarrySkyTree {",
//       "  int segn2;",
//       "  Type errorVal;",
//       "  vector<Type> data, s_data;",
//       "",
//       "  virtual Type merge(Type a, Type b) = 0;",
//       "",
//       "  StarrySkyTree(int n, Type errorVal): errorVal(errorVal) {",
//       "    for (segn2 = 1; segn2 < n; segn2 *= 2)",
//       "      ;",
//       "    data.assign(segn2 * 2, 0);",
//       "    s_data.assign(segn2 * 2, 0);",
//       "  }",
//       "",
//       "  //get value of [a,b)",
//       "  Type query(int a, int b, int l = 0, int r = -1, int k = 0) {",
//       "    if (r == -1) r = segn2;",
//       "    if (r <= a || b <= l) return errorVal;",
//       "    if (a <= l && r <= b) return data[k] + s_data[k];",
//       "    return merge(query(a, b, l, (l + r) / 2, k * 2 + 1), query(a, b, (l + r) / 2, r, k * 2 + 2)) + s_data[k];",
//       "  }",
//       "",
//       "  //add x to [a,b)",
//       "  Type add(int a, int b, Type x, int l = 0, int r = -1, int k = 0) {",
//       "    if (r == -1) r = segn2;",
//       "    if (a <= l && r <= b)",
//       "      s_data[k] += x;",
//       "    else if (a < r && l < b)",
//       "      data[k] = merge(add(a, b, x, l, (l + r) / 2, k * 2 + 1), add(a, b, x, (l + r) / 2, r, k * 2 + 2));",
//       "",
//       "    return data[k] + s_data[k];",
//       "  }",
//       "};",
//       "",
//       "template<typename Type = int>",
//       "struct StarrySkyTreeMax final: StarrySkyTree<Type> {",
//       "  StarrySkyTreeMax(int n, Type errorVal = -INF): StarrySkyTree<Type>(n, errorVal) {}",
//       "  Type merge(Type a, Type b) {",
//       "    return max(a, b);",
//       "  }",
//       "};",
//       "",
//       "template<typename Type = int>",
//       "struct StarrySkyTreeMin final: StarrySkyTree<Type> {",
//       "  StarrySkyTreeMin(int n, Type errorVal = INF): StarrySkyTree<Type>(n, errorVal) {}",
//       "  Type merge(Type a, Type b) {",
//       "    return min(a, b);",
//       "  }",
//       "};"
//     ],
//     "description": "Starry Sky Tree"
//   },
//   "Dynamic RangeAdd SegmentTree": {
//     "prefix": "dynamicseg",
//     "body": [
//       "template<typename T>",
//       "struct DynamicRangeAddSegtree {",
//       "  struct Node {",
//       "    T val, add;",
//       "    Node *l, *r;",
//       "",
//       "    Node(): val(0), add(0), l(NULL), r(NULL) {}",
//       "    ~Node() {",
//       "      if (l) delete l;",
//       "      if (r) delete r;",
//       "    }",
//       "  };",
//       "",
//       "  Node root;",
//       "  ll segn2;",
//       "",
//       "  DynamicRangeAddSegtree(ll n) {",
//       "    for (segn2 = 1; segn2 < n; segn2 *= 2)",
//       "      ;",
//       "  }",
//       "",
//       "  virtual T merge(T a, T b) = 0;",
//       "  virtual T rangeAdd(ll a, ll b, ll l, ll r, T add) = 0;",
//       "",
//       "  void add(ll a, ll b, T c) {",
//       "    add(a, b, c, 0, segn2, &root);",
//       "  }",
//       "",
//       "  T query(ll a, ll b) {",
//       "    return query(a, b, 0, segn2, &root);",
//       "  }",
//       "",
//       "private:",
//       "  T add(ll a, ll b, T c, ll l, ll r, Node *node) {",
//       "    if (!(r <= a || b <= l)) {",
//       "      if (a <= l && r <= b) {",
//       "        node->add += c;",
//       "      } else {",
//       "        if (node->l == NULL) node->l = new Node();",
//       "        if (node->r == NULL) node->r = new Node();",
//       "",
//       "        T lVal = add(a, b, c, l, (l + r) / 2, node->l);",
//       "        T rVal = add(a, b, c, (l + r) / 2, r, node->r);",
//       "",
//       "        node->val = merge(lVal, rVal);",
//       "      }",
//       "    }",
//       "",
//       "    return node->val + rangeAdd(l, r, l, r, node->add);",
//       "  }",
//       "",
//       "  T query(ll a, ll b, ll l, ll r, Node *node) {",
//       "    T res = 0;",
//       "    if (r <= a || b <= l) return 0;",
//       "",
//       "    if (a <= l && r <= b)",
//       "      return node->val + rangeAdd(a, b, l, r, node->add);",
//       "",
//       "    if (node->l) res = merge(res, query(a, b, l, (l + r) / 2, node->l));",
//       "    if (node->r) res = merge(res, query(a, b, (l + r) / 2, r, node->r));",
//       "",
//       "    return res + rangeAdd(a, b, l, r, node->add);",
//       "  }",
//       "};",
//       "",
//       "template<typename T>",
//       "struct DynamicRangeAddRangeSumSegtree final: DynamicRangeAddSegtree<T> {",
//       "  using DynamicRangeAddSegtree<T>::DynamicRangeAddSegtree;",
//       "  T merge(T a, T b) { return a + b; }",
//       "  T rangeAdd(ll a, ll b, ll l, ll r, T add) { return max(0LL, min(r, b) - max(a, l)) * add; }",
//       "};",
//       "",
//       "template<typename T>",
//       "struct DynamicRangeAddRangeMinSegtree final: DynamicRangeAddSegtree<T> {",
//       "  using DynamicRangeAddSegtree<T>::DynamicRangeAddSegtree;",
//       "  T merge(T a, T b) { return min(a, b); }",
//       "  T rangeAdd(ll a, ll b, ll l, ll r, T add) { return add; }",
//       "};",
//       "",
//       "template<typename T>",
//       "struct DynamicRangeAddRangeMaxSegtree final: DynamicRangeAddSegtree<T> {",
//       "  using DynamicRangeAddSegtree<T>::DynamicRangeAddSegtree;",
//       "  T merge(T a, T b) { return min(a, b); }",
//       "  T rangeAdd(ll a, ll b, ll l, ll r, T add) { return add; }",
//       "};"
//     ],
//     "description": "Dynamic RangeAdd SegmentTree"
//   },
//   "Binary Indexed Tree": {
//     "prefix": "bit",
//     "body": [
//       "/* Binary Indexed Tree(0-index) */",
//       "",
//       "template<typename Type = int>",
//       "struct BIT {",
//       "  int bit_size;",
//       "  vector<Type> data;",
//       "",
//       "  BIT(int n) {",
//       "    bit_size = n;",
//       "    data.assign(n + 2, 0);",
//       "  }",
//       "",
//       "  //add x to kth value",
//       "  void add(int k, Type x) {",
//       "    k++;",
//       "    while (k <= bit_size) {",
//       "      data[k] += x;",
//       "      k += k & (-k);",
//       "    }",
//       "  }",
//       "",
//       "  //sum of [0,k)",
//       "  Type query(int k) {",
//       "    Type rec = 0;",
//       "    while (k > 0) {",
//       "      rec += data[k];",
//       "      k -= k & (-k);",
//       "    }",
//       "    return rec;",
//       "  }",
//       "",
//       "  //sum of [a, b)",
//       "  Type query(int a, int b) {",
//       "    return query(b) - query(a);",
//       "  }",
//       "};"
//     ],
//     "description": "Binary Indexed Tree"
//   },
//   "Lazy Propagation Segment Tree(RangeSum)": {
//     "prefix": "lazyseg",
//     "body": [
//       "/* LazyPropagationSegmentTree(Sum) */",
//       "//0-index",
//       "",
//       "template<typename Type = int>",
//       "struct LazySeg_sum {",
//       "  struct Data {",
//       "    Type val, add, sum;",
//       "    bool valset;",
//       "",
//       "    Type calc_sum(int l, int r) {",
//       "      if (valset) return (val + add) * (r - l);",
//       "      return sum + add * (r - l);",
//       "    }",
//       "",
//       "    void set_data(Type x, Type y) {",
//       "      val = x;",
//       "      add = y;",
//       "      valset = true;",
//       "    }",
//       "",
//       "    void add_data(Type x) {",
//       "      add += x;",
//       "    }",
//       "",
//       "    Data(): val(0), add(0), sum(0), valset(false) {}",
//       "  };",
//       "",
//       "  vector<Data> data;",
//       "  int seg_size;",
//       "",
//       "  LazySeg_sum(int n) {",
//       "    for (seg_size = 1; seg_size < n; seg_size *= 2)",
//       "      ;",
//       "    data.assign(seg_size * 2, Data());",
//       "  }",
//       "",
//       "  // set value to [a, b)",
//       "  Type set(int a, int b, Type x, int l = 0, int r = -1, int k = 0) {",
//       "    if (r == -1) r = seg_size;",
//       "",
//       "    if (a <= l && r <= b) {",
//       "      data[k].set_data(x, 0);",
//       "      return data[k].calc_sum(l, r);",
//       "    }",
//       "",
//       "    if (r <= a || b <= l) return data[k].calc_sum(l, r);",
//       "",
//       "    if (data[k].valset) {",
//       "      data[k * 2 + 1].set_data(data[k].val, data[k].add);",
//       "      data[k * 2 + 2].set_data(data[k].val, data[k].add);",
//       "    } else {",
//       "      data[k * 2 + 1].add_data(data[k].add);",
//       "      data[k * 2 + 2].add_data(data[k].add);",
//       "    }",
//       "",
//       "    data[k].add = 0;",
//       "    data[k].valset = false;",
//       "    data[k].sum = set(a, b, x, l, (l + r) / 2, k * 2 + 1) + set(a, b, x, (l + r) / 2, r, k * 2 + 2);",
//       "",
//       "    return data[k].calc_sum(l, r);",
//       "  }",
//       "",
//       "  // add to [a, b)",
//       "  Type add(int a, int b, Type x, int l = 0, int r = -1, int k = 0) {",
//       "    if (r == -1) r = seg_size;",
//       "",
//       "    if (a <= l && r <= b) {",
//       "      data[k].add += x;",
//       "      return data[k].calc_sum(l, r);",
//       "    }",
//       "",
//       "    if (r <= a || b <= l) return data[k].calc_sum(l, r);",
//       "",
//       "    if (data[k].valset) {",
//       "      data[k * 2 + 1].set_data(data[k].val, data[k].add);",
//       "      data[k * 2 + 2].set_data(data[k].val, data[k].add);",
//       "      data[k].add = 0;",
//       "      data[k].valset = false;",
//       "    }",
//       "",
//       "    data[k].sum = add(a, b, x, l, (l + r) / 2, k * 2 + 1) + add(a, b, x, (l + r) / 2, r, k * 2 + 2);",
//       "",
//       "    return data[k].calc_sum(l, r);",
//       "  }",
//       "",
//       "  //get value of [a, b)",
//       "  Type query(int a, int b, int l = 0, int r = -1, int k = 0) {",
//       "    if (r == -1) r = seg_size;",
//       "",
//       "    if (r <= a || b <= l) return 0;",
//       "",
//       "    if ((a <= l && r <= b) || data[k].valset)",
//       "      return data[k].calc_sum(max(a, l), min(b, r));",
//       "",
//       "    return query(a, b, l, (l + r) / 2, k * 2 + 1) + query(a, b, (l + r) / 2, r, k * 2 + 2) +",
//       "           data[k].add * (min(b, r) - max(a, l));",
//       "  }",
//       "};"
//     ],
//     "description": "Lazy Propagation Segment Tree(RangeSum)"
//   },
//   "Range Tree": {
//     "prefix": "rangetree",
//     "body": [
//       "/* RangeTree */",
//       "",
//       "template<typename T>",
//       "struct RangeTree {",
//       "  vector<vector<T>> dat;",
//       "  int segn2, N;",
//       "",
//       "  RangeTree(int n, T *a): N(n) {",
//       "    for (segn2 = 1; segn2 < n; segn2 *= 2)",
//       "      ;",
//       "    dat.assign(segn2 * 2, vector<T>());",
//       "    init(a, 0, 0, n);",
//       "  }",
//       "",
//       "  void init(T *a, int k, int l, int r) {",
//       "    if (r - l == 1) {",
//       "      dat[k].push_back(a[l]);",
//       "    } else {",
//       "      int lch = k * 2 + 1, rch = k * 2 + 2;",
//       "      init(a, lch, l, (l + r) / 2);",
//       "      init(a, rch, (l + r) / 2, r);",
//       "      dat[k].resize(r - l);",
//       "",
//       "      merge(dat[lch].begin(), dat[lch].end(),",
//       "        dat[rch].begin(), dat[rch].end(),",
//       "        dat[k].begin());",
//       "    }",
//       "  }",
//       "",
//       "  //A[i:j-1] \u306e x\u4ee5\u4e0b\u306e\u500b\u6570",
//       "  int query(int i, int j, T x, int l = 0, int r = -1, int k = 0) {",
//       "    if (r == -1) r = N;",
//       "",
//       "    if (j <= l || r <= i) return 0;",
//       "",
//       "    if (i <= l && r <= j)",
//       "      return upper_bound(dat[k].begin(), dat[k].end(), x) - dat[k].begin();",
//       "",
//       "    int lc = query(i, j, x, l, (l + r) / 2, k * 2 + 1);",
//       "    int rc = query(i, j, x, (l + r) / 2, r, k * 2 + 2);",
//       "    return lc + rc;",
//       "  }",
//       "};"
//     ],
//     "description": "Range Tree"
//   },
//   "Li Chao Tree": {
//     "prefix": "lichao",
//     "body": [
//       "/* Li Chao Tree */",
//       "",
//       "template<typename T>",
//       "struct LiChaoTree {",
//       "  using Line = pair<T, T>; // first * x + second",
//       "",
//       "  int segn2;",
//       "  vector<Line> data;",
//       "  vector<T> X;",
//       "",
//       "  template<typename S>",
//       "  LiChaoTree(vector<S> pos) {",
//       "    int N = pos.size();",
//       "    for (segn2 = 1; segn2 < N; segn2 *= 2)",
//       "      ;",
//       "    data.assign(segn2 * 2, {0, INF});",
//       "    X.assign(segn2, INF);",
//       "    for (int i = 0; i < (int)pos.size(); i++)",
//       "      X[i] = pos[i];",
//       "  }",
//       "",
//       "  inline T f(Line line, T x) {",
//       "    return line.first * x + line.second;",
//       "  }",
//       "",
//       "  void addLine(int a, int b, Line line, int l = 0, int r = -1, int k = 0) {",
//       "    if (r == -1) r = segn2;",
//       "    int m = (l + r) / 2;",
//       "",
//       "    if (r <= a || b <= l) return;",
//       "    if (l < a || b < r) {",
//       "      addLine(a, b, line, l, m, k * 2 + 1);",
//       "      addLine(a, b, line, m, r, k * 2 + 2);",
//       "      return;",
//       "    }",
//       "    if (data[k].second == INF) { //isNull",
//       "      data[k] = line;",
//       "      return;",
//       "    }",
//       "",
//       "    bool fl = f(line, X[l]) < f(data[k], X[l]);",
//       "    bool fm = f(line, X[m]) < f(data[k], X[m]);",
//       "    bool fr = f(line, X[r - 1]) < f(data[k], X[r - 1]);",
//       "",
//       "    if (fl == fr) {",
//       "      if (fl) data[k] = line;",
//       "      return;",
//       "    }",
//       "    if (fm) swap(data[k], line);",
//       "",
//       "    if (fl ^ fm)",
//       "      addLine(a, b, line, l, m, 2 * k + 1);",
//       "    else",
//       "      addLine(a, b, line, m, r, 2 * k + 2);",
//       "  }",
//       "",
//       "  void addLine(Line line) { addLine(0, segn2, line); }",
//       "",
//       "  T query(int k) {",
//       "    T x = X[k], res = LLINF;",
//       "    k += segn2 - 1;",
//       "",
//       "    while (1) {",
//       "      if (data[k].second != INF) //isNotNull",
//       "        res = min(res, f(data[k], x));",
//       "      if (!k) break;",
//       "      k = (k - 1) / 2;",
//       "    }",
//       "",
//       "    return res;",
//       "  }",
//       "};"
//     ],
//     "description": "Li Chao Tree"
//   },
//   "UnionFind": {
//     "prefix": "unionfind",
//     "body": [
//       "/* UnionFind */",
//       "",
//       "struct UnionFind {",
//       "  vector<int> data;",
//       "  UnionFind(int s): data(s, -1) {}",
//       "",
//       "  int root(int x) {",
//       "    if (data[x] < 0) return x;",
//       "    return data[x] = root(data[x]);",
//       "  }",
//       "",
//       "  bool set(int x, int y) {",
//       "    x = root(x);",
//       "    y = root(y);",
//       "    if (x == y) return false;",
//       "    if (data[x] > data[y]) swap(x, y);",
//       "    data[x] += data[y];",
//       "    data[y] = x;",
//       "    return true;",
//       "  }",
//       "",
//       "  bool check(int x, int y) {",
//       "    return root(x) == root(y);",
//       "  }",
//       "",
//       "  int size(int x) {",
//       "    return -data[root(x)];",
//       "  }",
//       "};"
//     ],
//     "description": "UnionFind"
//   },
//   "Lowest Common Ancestor": {
//     "prefix": "lca",
//     "body": [
//       "/*Lowest Common Ancstor*/",
//       "struct LCA {",
//       "  int n;",
//       "  vector<vector<int>> tree, parent;",
//       "  vector<int> depth;",
//       "  int log2n;",
//       "",
//       "  LCA(int n): n(n), tree(n), depth(n, -1) {",
//       "    log2n = 0;",
//       "    for (log2n = 1; (1 << log2n) < n; log2n++)",
//       "      ;",
//       "    parent.assign(log2n, vector<int>(n, -1));",
//       "  }",
//       "",
//       "  void add_edge(int u, int v) {",
//       "    tree[u].push_back(v);",
//       "    tree[v].push_back(u);",
//       "  }",
//       "",
//       "  void dfs(int now, int p, int d) {",
//       "    parent[0][now] = p;",
//       "    depth[now] = d;",
//       "",
//       "    for (int to : tree[now])",
//       "      if (to != p)",
//       "        dfs(to, now, d + 1);",
//       "  }",
//       "",
//       "  void build(int root) {",
//       "    dfs(root, -1, 0);",
//       "",
//       "    for (int i = 0; i < log2n - 1; i++)",
//       "      for (int j = 0; j < n; j++)",
//       "        parent[i + 1][j] = parent[i][j] == -1 ? -1 : parent[i][parent[i][j]];",
//       "  }",
//       "",
//       "  int query(int a, int b) {",
//       "    if (depth[a] > depth[b]) swap(a, b);",
//       "",
//       "    for (int i = 0; i < log2n; i++)",
//       "      if ((depth[b] - depth[a]) >> i & 1)",
//       "        b = parent[i][b];",
//       "",
//       "    if (a == b) return a;",
//       "",
//       "    for (int i = log2n - 1; i >= 0; i--) {",
//       "      if (parent[i][a] != parent[i][b]) {",
//       "        a = parent[i][a];",
//       "        b = parent[i][b];",
//       "      }",
//       "    }",
//       "",
//       "    return parent[0][a];",
//       "  }",
//       "};"
//     ],
//     "description": "Lowest Common Ancestor"
//   },
//   "Centroid Decomposition": {
//     "prefix": "centroid",
//     "body": [
//       "/* \u91cd\u5fc3\u5206\u89e3 */",
//       "",
//       "struct CentroidDecomposition {",
//       "  int n;",
//       "  vector<vector<int>> G;",
//       "  vector<int> sub, used;",
//       "",
//       "  CentroidDecomposition(int n): n(n), G(n, vector<int>()), sub(n, 0), used(n, 0) {}",
//       "",
//       "  void addEdge(int u, int v) {",
//       "    G[u].push_back(v);",
//       "    G[v].push_back(u);",
//       "  }",
//       "",
//       "  int build(int now, int prev) {",
//       "    sub[now] = 1;",
//       "    for (auto to : G[now]) {",
//       "      if (to != prev && !used[to])",
//       "        sub[now] += build(to, now);",
//       "    }",
//       "    return sub[now];",
//       "  }",
//       "",
//       "  int searchCentroid(int now, int prev, int mid) {",
//       "    for (auto to : G[now]) {",
//       "      if (to == prev || used[to]) continue;",
//       "      if (sub[to] > mid) return searchCentroid(to, now, mid);",
//       "    }",
//       "    return now;",
//       "  }",
//       "",
//       "  int solve(int now, const function<void(int, vector<int> &)> &func) {",
//       "    vector<int> children;",
//       "    int centroid = searchCentroid(now, -1, build(now, -1) / 2);",
//       "    //func(centroid, children); //before",
//       "    used[centroid] = true;",
//       "    for (auto to : G[centroid])",
//       "      if (!used[to])",
//       "        children.push_back(solve(to, func));",
//       "    func(centroid, children); //after",
//       "    return centroid;",
//       "  }",
//       "};",
//       "",
//       "// auto func = [&](int centroid, vector<int> &vec){}"
//     ],
//     "description": "Centroid Decomposition"
//   },
//   "Dijkstra": {
//     "prefix": "dijkstra",
//     "body": [
//       "/* Dijkstra O(NlogM)*/",
//       "",
//       "template<typename Type = int>",
//       "struct Dijkstra {",
//       "  int V;",
//       "  vector<vector<pair<int, Type>>> G;",
//       "  vector<Type> cost;",
//       "",
//       "  Dijkstra(int n): V(n), G(n, vector<pair<int, Type>>()) {}",
//       "",
//       "  void add_edge(int u, int v, Type c) {",
//       "    G[u].push_back({v, c});",
//       "  }",
//       "",
//       "  Type solve(int s, int g = -1) {",
//       "    cost.assign(V, -1);",
//       "    priority_queue<pair<Type, int>> pq;",
//       "    Type max_cost = 0;",
//       "",
//       "    pq.push({0, s});",
//       "",
//       "    while (pq.size()) {",
//       "      Type now_cost = pq.top().first;",
//       "      int now = pq.top().second;",
//       "      pq.pop();",
//       "",
//       "      if (cost[now] >= 0) continue;",
//       "",
//       "      cost[now] = -now_cost;",
//       "      max_cost = max(max_cost, -now_cost);",
//       "",
//       "      if (now == g) return -now_cost;",
//       "",
//       "      for (int i = 0; i < (int)G[now].size(); i++)",
//       "        pq.push({now_cost - G[now][i].second, G[now][i].first});",
//       "    }",
//       "",
//       "    return max_cost;",
//       "  }",
//       "};"
//     ],
//     "description": "Dijkstra"
//   },
//   "Topological Sort": {
//     "prefix": "tsort",
//     "body": [
//       "/* TopologicalSort */",
//       "",
//       "vector<int> TopologicalSort(const vector<vector<int>> &G, int n = -1) {",
//       "  if (n == -1) n = (int)G.size();",
//       "",
//       "  queue<int> que;",
//       "  vector<int> res, indeg(n + 1, 0);",
//       "",
//       "  for (int i = 0; i < n; i++)",
//       "    for (int v : G[i])",
//       "      indeg[v]++;",
//       "",
//       "  for (int i = 0; i < n; i++)",
//       "    if (indeg[i] == 0)",
//       "      que.push(i);",
//       "",
//       "  while (que.size()) {",
//       "    int u = que.front();",
//       "    que.pop();",
//       "",
//       "    res.push_back(u);",
//       "",
//       "    for (int v : G[u]) {",
//       "      indeg[v]--;",
//       "      if (indeg[v] == 0) que.push(v);",
//       "    }",
//       "  }",
//       "",
//       "  return n == (int)res.size() ? res : vector<int>();",
//       "}"
//     ],
//     "description": "Topological Sort"
//   },
//   "Bridges \\& 2-edge-connected Components": {
//     "prefix": "bridges",
//     "body": [
//       "/* Bridges & 2-edge-connected Components */",
//       "",
//       "struct Bridges {",
//       "  vector<pair<int, int>> edges;",
//       "  vector<vector<pair<int, int>>> G;",
//       "",
//       "  vector<int> cmp, isBridge; //\u5727\u7e2e\u5f8c\u306b\u5c5e\u3059\u308bComponent\u756a\u53f7, \u6a4b\u3067\u3042\u308b\u304b",
//       "  vector<pair<int, int>> cmpEdges; //\u5727\u7e2e\u5f8c\u306eedge",
//       "",
//       "  int idx, cmpIdx;",
//       "  vector<int> ord, inSt;",
//       "  stack<int> roots, st;",
//       "",
//       "  Bridges(int N): G(N, vector<pair<int, int>>()), cmp(N), idx(0), cmpIdx(0), ord(N, -1), inSt(N, 0) {}",
//       "",
//       "  void add_edge(int u, int v) {",
//       "    G[u].push_back({v, edges.size()});",
//       "    G[v].push_back({u, edges.size()});",
//       "    edges.push_back({u, v});",
//       "    isBridge.push_back(false);",
//       "  }",
//       "",
//       "  void dfs(int now, int eid = -1) {",
//       "    ord[now] = idx++;",
//       "    roots.push(now);",
//       "    st.push(now);",
//       "    inSt[now] = true;",
//       "",
//       "    for (auto e : G[now]) {",
//       "      int to = e.first;",
//       "      if (ord[to] == -1)",
//       "        dfs(to, e.second);",
//       "      else if (eid != e.second && inSt[to])",
//       "        while (ord[roots.top()] > ord[to]) roots.pop();",
//       "    }",
//       "    if (now == roots.top()) {",
//       "      while (1) {",
//       "        int w = st.top();",
//       "        st.pop();",
//       "        inSt[w] = false;",
//       "        cmp[w] = cmpIdx;",
//       "        if (now == w) break;",
//       "      }",
//       "      if (eid != -1) isBridge[eid] = true;",
//       "      roots.pop();",
//       "      cmpIdx++;",
//       "    }",
//       "  }",
//       "",
//       "  void build() {",
//       "    for (int i = 0; i < (int)ord.size(); i++)",
//       "      if (ord[i] == -1)",
//       "        dfs(i);",
//       "",
//       "    for (int i = 0; i < (int)edges.size(); i++) {",
//       "      if (isBridge[i])",
//       "        cmpEdges.push_back({cmp[edges[i].first], cmp[edges[i].second]});",
//       "    }",
//       "  }",
//       "};"
//     ],
//     "description": "Bridges \\& 2-edge-connected Components"
//   },
//   "Bipartite Matching": {
//     "prefix": "2match",
//     "body": [
//       "/* Bipartite Matching */",
//       "",
//       "struct BipartiteMatching {",
//       "  int V;",
//       "  vector<vector<int>> G;",
//       "  vector<int> match;",
//       "  vector<bool> used;",
//       "",
//       "  BipartiteMatching(int n): V(n), G(n) {}",
//       "",
//       "  void add_edge(int u, int v) {",
//       "    G[u].push_back(v);",
//       "    G[v].push_back(u);",
//       "  }",
//       "",
//       "  bool dfs(int v) {",
//       "    used[v] = true;",
//       "    for (int u : G[v]) {",
//       "      int w = match[u];",
//       "      if (w < 0 || (!used[w] && dfs(w))) {",
//       "        match[v] = u;",
//       "        match[u] = v;",
//       "        return true;",
//       "      }",
//       "    }",
//       "    return false;",
//       "  }",
//       "",
//       "  int solve() {",
//       "    int res = 0;",
//       "    match.assign(V, -1);",
//       "    for (int i = 0; i < V; i++) {",
//       "      if (match[i] < 0) {",
//       "        used.assign(V, false);",
//       "        if (dfs(i)) res++;",
//       "      }",
//       "    }",
//       "    return res;",
//       "  }",
//       "};"
//     ],
//     "description": "Bipartite Matching"
//   },
//   "Maximum Matching": {
//     "prefix": "maxmatch",
//     "body": [
//       "/* \u6700\u5927\u30de\u30c3\u30c1\u30f3\u30b0 */",
//       "// https://qiita.com/Kutimoti_T/items/5b579773e0a24d650bdf",
//       "",
//       "struct MaximumMatching {",
//       "  int N;",
//       "  vector<vector<pair<int, int>>> G;",
//       "  vector<pair<int, int>> edges;",
//       "  vector<int> first, mate, label;",
//       "  queue<int> que;",
//       "",
//       "  MaxMatching(int N): N(N), G(N + 1), first(N + 1), mate(N + 1), label(N + 1, -1) {}",
//       "",
//       "  void add_edge(int a, int b) {",
//       "    int id = edges.size() + N + 1;",
//       "    a++;",
//       "    b++;",
//       "    G[a].push_back({b, id});",
//       "    G[b].push_back({a, id});",
//       "    edges.push_back({a, b});",
//       "  }",
//       "",
//       "  void rematch(int u, int v) {",
//       "    int t = mate[u], s = label[u];",
//       "    mate[u] = v;",
//       "    if (mate[t] != u) return;",
//       "    if (s <= N) {",
//       "      mate[t] = s;",
//       "      rematch(s, t);",
//       "    } else {",
//       "      int x = edges[s - N - 1].first;",
//       "      int y = edges[s - N - 1].second;",
//       "      rematch(x, y);",
//       "      rematch(y, x);",
//       "    }",
//       "  }",
//       "",
//       "  int evalFirst(int x) {",
//       "    int &t = first[x];",
//       "    if (label[t] < 0) return t;",
//       "    return t = evalFirst(t);",
//       "  }",
//       "",
//       "  void assignLabel(int x, int y, int num) {",
//       "    int r = evalFirst(x), s = evalFirst(y);",
//       "    int join = 0;",
//       "    if (r == s) return;",
//       "",
//       "    label[r] = label[s] = -num;",
//       "",
//       "    while (1) {",
//       "      if (s != 0) swap(r, s);",
//       "      r = evalFirst(label[mate[r]]);",
//       "      if (label[r] == -num) {",
//       "        join = r;",
//       "        break;",
//       "      }",
//       "      label[r] = -num;",
//       "    }",
//       "",
//       "    for (int t : {x, y}) {",
//       "      int v = first[t];",
//       "      while (v != join) {",
//       "        que.push(v);",
//       "        label[v] = num;",
//       "        first[v] = join;",
//       "        v = first[label[mate[v]]];",
//       "      }",
//       "    }",
//       "  }",
//       "",
//       "  bool augmentCheck(int u) {",
//       "    first[u] = label[u] = 0;",
//       "    que.push(u);",
//       "",
//       "    while (que.size()) {",
//       "      int x = que.front();",
//       "      que.pop();",
//       "      for (auto e : G[x]) {",
//       "        int y = e.first, &p = mate[y];",
//       "        if (p == 0 && y != u) {",
//       "          p = x;",
//       "          rematch(x, y);",
//       "          return true;",
//       "        } else if (label[y] >= 0) {",
//       "          assignLabel(x, y, e.second);",
//       "        } else if (label[p] < 0) {",
//       "          label[p] = x;",
//       "          first[p] = y;",
//       "          que.push(p);",
//       "        }",
//       "      }",
//       "    }",
//       "    return false;",
//       "  }",
//       "",
//       "  vector<pair<int, int>> solve() {",
//       "    for (int i = 1; i <= N; i++) {",
//       "      que = queue<int>();",
//       "      if (mate[i] != 0) continue;",
//       "      if (augmentCheck(i))",
//       "        fill(label.begin(), label.end(), -1);",
//       "    }",
//       "",
//       "    vector<pair<int, int>> ans;",
//       "    for (int i = 1; i <= N; i++)",
//       "      if (i < mate[i]) ans.push_back({i - 1, mate[i] - 1});",
//       "",
//       "    return ans;",
//       "  }",
//       "};"
//     ],
//     "description": "Maximum Matching"
//   },
//   "Maximum Flow (Dinic)": {
//     "prefix": "dinic",
//     "body": [
//       "/* Maximum flow (Dinic) */",
//       "",
//       "struct Dinic {",
//       "  struct edge {",
//       "    int to, cap, rev;",
//       "    edge(int a, int b, int c): to(a), cap(b), rev(c) {}",
//       "  };",
//       "",
//       "  vector<vector<edge>> G;",
//       "  vector<int> level, iter;",
//       "  int MAX_V;",
//       "",
//       "  Dinic(int max_v): G(max_v), MAX_V(max_v) {}",
//       "",
//       "  int add_edge(int from, int to, int cap) {",
//       "    int id = G[from].size();",
//       "",
//       "    G[from].push_back(edge(to, cap, G[to].size()));",
//       "    G[to].push_back(edge(from, 0, G[from].size() - 1));",
//       "",
//       "    return id;",
//       "  }",
//       "",
//       "  void bfs(int s) {",
//       "    queue<int> q;",
//       "    level.assign(MAX_V, -1);",
//       "    level[s] = 0;",
//       "    q.push(s);",
//       "    while (q.size()) {",
//       "      int v = q.front();",
//       "      q.pop();",
//       "      for (edge e : G[v]) {",
//       "        if (e.cap > 0 && level[e.to] < 0) {",
//       "          level[e.to] = level[v] + 1;",
//       "          q.push(e.to);",
//       "        }",
//       "      }",
//       "    }",
//       "  }",
//       "",
//       "  int dfs(int v, int t, int f) {",
//       "    if (v == t) return f;",
//       "    for (int &i = iter[v]; i < (int)G[v].size(); i++) {",
//       "      edge &e = G[v][i];",
//       "      if (e.cap > 0 && level[v] < level[e.to]) {",
//       "        int d = dfs(e.to, t, min(f, e.cap));",
//       "        if (d > 0) {",
//       "          e.cap -= d;",
//       "          G[e.to][e.rev].cap += d;",
//       "          return d;",
//       "        }",
//       "      }",
//       "    }",
//       "    return 0;",
//       "  }",
//       "",
//       "  int solve(int s, int t) {",
//       "    int flow = 0, f;",
//       "    while (1) {",
//       "      bfs(s);",
//       "      if (level[t] < 0) return flow;",
//       "      iter.assign(MAX_V, 0);",
//       "      while ((f = dfs(s, t, INF)) > 0) flow += f;",
//       "    }",
//       "  }",
//       "};"
//     ],
//     "description": "Maximum Flow (Dinic)"
//   },
//   "Minimum Cost Flow": {
//     "prefix": "mincostflow",
//     "body": [
//       "/* Minimum Cost Flow */",
//       "",
//       "template<typename Type = int, Type inf = INF>",
//       "struct MinimumCostFlow {",
//       "  typedef pair<Type, int> P;",
//       "",
//       "  struct edge {",
//       "    int to, cap, rev;",
//       "    Type cost;",
//       "    edge(int a, int b, int c, Type d): to(a), cap(b), rev(c), cost(d) {}",
//       "  };",
//       "",
//       "  vector<vector<edge>> G;",
//       "  vector<int> prevv, preve;",
//       "  vector<Type> h, dist;",
//       "  int V;",
//       "",
//       "  MinimumCostFlow(int v): G(v, vector<edge>()), prevv(v, 0), preve(v, 0), V(v) {}",
//       "",
//       "  int add_edge(int from, int to, int cap, Type cost) {",
//       "    int id = G[from].size();",
//       "",
//       "    G[from].push_back(edge(to, cap, G[to].size(), cost));",
//       "    G[to].push_back(edge(from, 0, G[from].size() - 1, -cost));",
//       "",
//       "    return id;",
//       "  }",
//       "",
//       "  Type solve(int s, int t, int f) {",
//       "    Type res = 0;",
//       "    h.assign(V, 0);",
//       "    while (f > 0) {",
//       "      priority_queue<P, vector<P>, greater<P>> pq;",
//       "      dist.assign(V, inf);",
//       "      dist[s] = 0;",
//       "      pq.push(P(0, s));",
//       "      while (pq.size()) {",
//       "        P p = pq.top();",
//       "        pq.pop();",
//       "        int v = p.second;",
//       "        if (dist[v] < p.first) continue;",
//       "",
//       "        for (int i = 0; i < (int)G[v].size(); i++) {",
//       "          edge &e = G[v][i];",
//       "          Type d = dist[v] + e.cost + h[v] - h[e.to];",
//       "          if (e.cap > 0 && dist[e.to] > d) {",
//       "            dist[e.to] = d;",
//       "            prevv[e.to] = v;",
//       "            preve[e.to] = i;",
//       "            pq.push(P(dist[e.to], e.to));",
//       "          }",
//       "        }",
//       "      }",
//       "      if (dist[t] == inf) return -1;",
//       "",
//       "      for (int v = 0; v < V; v++) h[v] += dist[v];",
//       "",
//       "      int d = f;",
//       "      for (int v = t; v != s; v = prevv[v])",
//       "        d = min(d, G[prevv[v]][preve[v]].cap);",
//       "",
//       "      f -= d;",
//       "      res += d * h[t];",
//       "",
//       "      for (int v = t; v != s; v = prevv[v]) {",
//       "        edge &e = G[prevv[v]][preve[v]];",
//       "        e.cap -= d;",
//       "        G[v][e.rev].cap += d;",
//       "      }",
//       "    }",
//       "",
//       "    return res;",
//       "  }",
//       "};"
//     ],
//     "description": "Minimum Cost Flow"
//   },
//   "Strongly Connected Component": {
//     "prefix": "scc",
//     "body": [
//       "/* Strongly Connected Component */",
//       "",
//       "/*",
//       " 1. dfs\u3092\u3057\u3066\u3001\u623b\u308b\u3068\u304d\u306b1\u304b\u3089\u9806\u306b\u756a\u53f7\u3092\u4ed8\u3051\u308b",
//       " 2. \u6570\u5024\u304c\u5927\u304d\u3044\u30ce\u30fc\u30c9\u304b\u3089\u9006\u8fba\u3092\u4f7f\u3063\u3066dfs\u3092\u3059\u308b\u3002",
//       "    \u3059\u3067\u306b\u8a2a\u308c\u3066\u3044\u308b\u30ce\u30fc\u30c9\u306b\u306f\u884c\u304b\u306a\u3044\u3002",
//       "    \u305f\u3069\u308a\u7740\u3051\u308b\u30ce\u30fc\u30c9\u304c\u540c\u3058\u9023\u7d50\u6210\u5206\u306b\u5c5e\u3059\u308b\u3002",
//       " */",
//       "",
//       "struct SCC {",
//       "  int n;",
//       "  vector<vector<int>> G, rG;",
//       "  vector<int> vs, cmp;",
//       "  vector<bool> used;",
//       "",
//       "  SCC(int n): n(n), G(n), rG(n), cmp(n) {}",
//       "",
//       "  void add_edge(int from, int to) {",
//       "    G[from].push_back(to);",
//       "    rG[to].push_back(from);",
//       "  }",
//       "",
//       "  void dfs(int v) {",
//       "    used[v] = true;",
//       "    for (int to : G[v])",
//       "      if (!used[to]) dfs(to);",
//       "    vs.push_back(v);",
//       "  }",
//       "",
//       "  void rdfs(int v, int k) {",
//       "    used[v] = true;",
//       "    cmp[v] = k;",
//       "    for (int to : rG[v])",
//       "      if (!used[to]) rdfs(to, k);",
//       "  }",
//       "",
//       "  int solve() {",
//       "    used.assign(n, false);",
//       "    vs.clear();",
//       "    for (int i = 0; i < n; i++)",
//       "      if (!used[i]) dfs(i);",
//       "    used.assign(n, false);",
//       "    int k = 0;",
//       "    for (int i = (int)vs.size() - 1; i >= 0; i--)",
//       "      if (!used[vs[i]]) rdfs(vs[i], k++);",
//       "    return k; //\u5f37\u9023\u7d50\u6210\u5206\u6570",
//       "  }",
//       "",
//       "  //\u5c5e\u3059\u308b\u5f37\u9023\u7d50\u6210\u5206\u756a\u53f7(\u30c8\u30dd\u30ed\u30b8\u30ab\u30eb\u9806)",
//       "  int operator[](int k) const {",
//       "    return cmp[k];",
//       "  }",
//       "};"
//     ],
//     "description": "Strongly Connected Component"
//   },
//   "2-SAT": {
//     "prefix": "2sat",
//     "body": [
//       "/* 2-SAT (Source: \u87fb\u672c)*/",
//       "",
//       "struct TwoSAT {",
//       "  int n;",
//       "  SCC scc;",
//       "  vector<bool> ans;",
//       "",
//       "  TwoSAT(int n): n(n), scc(n * 2), ans(n) {}",
//       "",
//       "  //1-index, add(1, -2) -> p or not q",
//       "  void add(int a, int b) {",
//       "    a = a > 0 ? a - 1 : n - a - 1;",
//       "    b = b > 0 ? b - 1 : n - b - 1;",
//       "    scc.add_edge((a + n) % (2 * n), b);",
//       "    scc.add_edge((b + n) % (2 * n), a);",
//       "  }",
//       "",
//       "  bool solve() {",
//       "    scc.solve();",
//       "    for (int i = 0; i < n; i++)",
//       "      if (scc.cmp[i] == scc.cmp[n + i]) return false;",
//       "",
//       "    for (int i = 0; i < n; i++)",
//       "      ans[i] = scc.cmp[i] > scc.cmp[n + i];",
//       "    return true;",
//       "  }",
//       "};"
//     ],
//     "description": "2-SAT"
//   },
//   "Geometry Template": {
//     "prefix": "geotemp",
//     "body": [
//       "typedef double P_type; //\u5ea7\u6a19(integer or real)",
//       "typedef double G_real; //\u5b9f\u6570\u306e\u623b\u308a\u5024(float or double or long double)",
//       "typedef complex<P_type> P;",
//       "const G_real P_eps = 1e-8; //\u6574\u6570\u306e\u6642\u306f\u30bc\u30ed",
//       "",
//       "namespace std {",
//       "  template<class T>",
//       "  bool operator<(const complex<T> &a, const complex<T> &b) {",
//       "    return abs(a.real() - b.real()) < P_eps ? a.imag() + P_eps < b.imag() : a.real() + P_eps < b.real();",
//       "  }",
//       "};",
//       "",
//       "P rotate(P p, double theta) {",
//       "  return p * P(cos(theta), sin(theta));",
//       "}",
//       "",
//       "//\u5185\u7a4d",
//       "P_type dot(P a, P b) {",
//       "  return (a * conj(b)).real();",
//       "}",
//       "",
//       "//\u5916\u7a4d",
//       "P_type cross(P a, P b) {",
//       "  return (conj(a) * b).imag();",
//       "}",
//       "",
//       "//\u53cd\u6642\u8a08\u56de\u308a",
//       "int ccw(P a, P b, P c) {",
//       "  if (cross(b - a, c - a) > P_eps) return 1; //COUNTER_CLOCKWISE(center:a)",
//       "  if (cross(b - a, c - a) < -P_eps) return -1; //CLOCKWISE(center:a)",
//       "  if (dot(b - a, c - a) < -P_eps) return -2; //c -> a -> b",
//       "  if (dot(a - b, c - b) < -P_eps) return 2; //a -> b -> c",
//       "  return 0; //a -> c -> b",
//       "}",
//       "",
//       "/*",
//       "// \u504f\u89d2 [-pi, pi]",
//       "// complex<int|ll> \u4f7f\u7528\u6642\u306e std::arg \u306e\u4ee3\u308f\u308a",
//       "G_real arg(P p) {",
//       "  return atan2(imag(p), real(p));",
//       "}",
//       "*/"
//     ],
//     "description": "Geometry Template"
//   },
//   "Geometry Library": {
//     "prefix": "geolib",
//     "body": [
//       "/* \u30d9\u30af\u30c8\u30eba, b\u306e\u89d2\u5ea6 */",
//       "// ({0, 1}, {1, 0}) => 90, ({0, 1}, {-1, -1}) => -135",
//       "G_real degree(P a, P b) {",
//       "  return atan2(cross(b, a), dot(b, a)) / M_PI * 180;",
//       "}",
//       "",
//       "/* \u7dda\u5206ab\u3068\u70b9c\u306e\u8ddd\u96e2 */",
//       "G_real distanceSP(P a, P b, P c) {",
//       "  if (dot(b - a, c - a) < P_eps) return abs(c - a);",
//       "  if (dot(a - b, c - b) < P_eps) return abs(c - b);",
//       "  return abs(cross(b - a, c - a)) / abs(b - a);",
//       "}",
//       "",
//       "/* \u76f4\u7ddaab\u3068\u70b9c\u306e\u8ddd\u96e2 */",
//       "G_real distanceLP(P a, P b, P c) {",
//       "  return abs(cross(b - a, c - a)) / abs(b - a);",
//       "}",
//       "",
//       "/* \u5186\u306e\u70b9\u5305\u542b\u5224\u5b9a */",
//       "bool isContainedCP(P c, P_type r, P p) {",
//       "  return abs(c - p) < r - P_eps; //\u5186\u5468\u4e0a\u3092\u542b\u307e\u306a\u3044",
//       "  //return abs(c-p) <= r + P_eps; //\u5186\u5468\u4e0a\u3092\u542b\u3080",
//       "}",
//       "",
//       "/* \u5186\u306e\u5186\u5305\u542b\u5224\u5b9a (\u51861\u306e\u5185\u90e8\u306b\u51862\u304c\u5b58\u5728\u3059\u308b\u304b) */",
//       "bool isContainedCC(P c1, P_type r1, P c2, P_type r2) {",
//       "  return abs(c1 - c2) + r2 < r1 - P_eps; //\u63a5\u3059\u308b\u5834\u5408\u3092\u542b\u307e\u306a\u3044",
//       "  //return abs(c1 - c2) + r2 <= r1 + P_eps; //\u63a5\u3059\u308b\u5834\u5408\u3092\u542b\u307e\u306a\u3044",
//       "}",
//       "",
//       "/* \u76f4\u7dda\u4ea4\u5dee\u5224\u5b9a */",
//       "bool isIntersectedLL(P a1, P a2, P b1, P b2) {",
//       "  return abs(cross(a1 - a2, b1 - b2)) > P_eps;",
//       "}",
//       "",
//       "/* \u7dda\u5206\u4ea4\u5dee\u5224\u5b9a */",
//       "bool isIntersectedSS(P a1, P a2, P b1, P b2) {",
//       "  //\u7dda\u5206a \u3068 \u76f4\u7ddab",
//       "  int a = ccw(b1, b2, a1);",
//       "  int b = ccw(b1, b2, a2);",
//       "",
//       "  //\u7dda\u5206b \u3068 \u76f4\u7ddaa",
//       "  int c = ccw(a1, a2, b1);",
//       "  int d = ccw(a1, a2, b2);",
//       "",
//       "  return a * b <= 0 && c * d <= 0; // T\u5b57\u3092\u9664\u304f\u6642\u306f (** < 0)",
//       "}",
//       "",
//       "/* \u76f4\u7ddaA\u7dda\u5206B\u4ea4\u5dee\u5224\u5b9a */",
//       "bool isIntersectedLS(P a1, P a2, P b1, P b2) {",
//       "  int a = ccw(a1, a2, b1);",
//       "  int b = ccw(a1, a2, b2);",
//       "",
//       "  // \u76f4\u7dda\u4e0a\u306e\u3068\u304d a or b = 0 or -2 or 2",
//       "  return (a % 2) * (b % 2) <= 0; // T\u5b57\u3092\u9664\u304f\u6642\u306f (** < 0)",
//       "}",
//       "",
//       "/* \u5186\u4ea4\u5dee\u5224\u5b9a */",
//       "bool isIntersectedCC(P c1, G_real r1, P c2, P_type r2) {",
//       "  G_real dist = abs(c1 - c2);",
//       "",
//       "  return abs(r1 - r2) <= dist + P_eps && dist - P_eps <= r1 + r2; //\u5916\u63a5\u5185\u63a5\u3092\u542b\u3080",
//       "  //return abs(r1 - r2) < dist - P_eps && dist + P_eps < r1 + r2; //\u5916\u63a5\u5185\u63a5\u3092\u9664\u304f",
//       "}",
//       "",
//       "/* \u5186\u76f4\u7dda\u4ea4\u5dee\u5224\u5b9a */",
//       "bool isIntersectedCL(P c, G_real r, P a1, P a2) {",
//       "  return distanceLP(a1, a2, c) <= r + P_eps; //\u63a5\u3059\u308b\u5834\u5408\u3092\u542b\u307e\u306a\u3044\u5834\u5408 < r - P_eps",
//       "}",
//       "",
//       "/* \u5186\u7dda\u5206\u4ea4\u5dee\u5224\u5b9a */",
//       "bool isIntersectedCS(P c, P_type r, P a1, P a2) {",
//       "  return (!isContainedCP(c, r, a1) || !isContainedCP(c, r, a2)) &&",
//       "         distanceLP(a1, a2, c) <= r + P_eps; //\u63a5\u3059\u308b\u5834\u5408\u3092\u542b\u307e\u306a\u3044\u5834\u5408 < r - P_eps",
//       "}",
//       "",
//       "/* \u76f4\u7dda/\u7dda\u5206\u4ea4\u70b9 */",
//       "vector<P> getCrosspointLL(P a1, P a2, P b1, P b2) {",
//       "  if (!isIntersectedLL(a1, a2, b1, b2)) return {};",
//       "",
//       "  P a = a2 - a1;",
//       "  P b = b2 - b1;",
//       "  return {a1 + a * cross(b, b1 - a1) / cross(b, a)};",
//       "}",
//       "",
//       "vector<P> getCrosspointSS(P a1, P a2, P b1, P b2) {",
//       "  if (!isIntersectedSS(a1, a2, b1, b2)) return {};",
//       "  return getCrosspointLL(a1, a2, b1, b2);",
//       "}",
//       "",
//       "/* \u5186\u4ea4\u70b9 */",
//       "vector<P> getCrosspointCC(P c1, P_type r1, P c2, P_type r2) {",
//       "  if (!isIntersectedCC(c1, r1, c2, r2)) return {};",
//       "",
//       "  P_type dist = abs(c1 - c2);",
//       "  P_type a = acos((r1 * r1 + dist * dist - r2 * r2) / (2 * r1 * dist));",
//       "  return {c1 + polar(r1, arg(c2 - c1) + a), c1 + polar(r1, arg(c2 - c1) - a)};",
//       "}",
//       "",
//       "/* \u5186\u76f4\u7dda\u4ea4\u70b9 */",
//       "vector<P> getCrosspointCL(P c, P_type r, P a1, P a2) {",
//       "  if (!isIntersectedCL(c, r, a1, a2)) return {};",
//       "",
//       "  P base1 = a2 - a1;",
//       "  P proj = a1 + base1 * dot(c - a1, base1) / norm(base1); //\u5c04\u5f71",
//       "  P e = (a2 - a1) / abs(a2 - a1);",
//       "  P base2 = sqrt(r * r - norm(proj - c));",
//       "  return {proj - e * base2, proj + e * base2};",
//       "}",
//       "",
//       "/* \u5186\u7dda\u5206\u4ea4\u70b9 */",
//       "vector<P> getCrosspointCS(P c, P_type r, P a1, P a2) {",
//       "  if (!isIntersectedCS(c, r, a1, a2)) return {};",
//       "",
//       "  vector<P> res;",
//       "  for (P p : getCrosspointCL(c, r, a1, a2))",
//       "    if (dot(a1 - p, a2 - p) <= P_eps) res.push_back(p);",
//       "  return res;",
//       "}",
//       "",
//       "/* \u591a\u89d2\u5f62-\u70b9\u5305\u542b */",
//       "bool isContainedPolyP(vector<P> &g, P p) {",
//       "  int n = g.size();",
//       "  bool f = false;",
//       "  for (int i = 0; i < n; i++) {",
//       "    P a = g[i] - p, b = g[(i + 1) % n] - p;",
//       "    if (abs(cross(a, b)) < P_eps && dot(a, b) < P_eps) return true; //\u8fba\u4e0a",
//       "    if (a.imag() > b.imag()) swap(a, b);",
//       "    if (a.imag() < P_eps && P_eps < b.imag() && cross(a, b) > P_eps) f = !f;",
//       "  }",
//       "  return f; //\u5185\u90e8 or \u5916\u90e8",
//       "}",
//       "",
//       "/* \u5c04\u5f71(\u76f4\u7ddaab\u3068p\u304b\u3089\u306e\u5782\u7dda\u3068\u306e\u4ea4\u70b9) */",
//       "P getProject(P a, P b, P p) {",
//       "  P base = b - a;",
//       "  return a + base * dot(p - a, base) / norm(base);",
//       "}",
//       "",
//       "/* \u53cd\u5c04(\u76f4\u7ddaab\u3092\u5bfe\u79f0\u8ef8\u3068\u3057\u305fp\u306e\u7dda\u5bfe\u79f0\u306e\u4f4d\u7f6e) */",
//       "P getReflection(P a, P b, P p) {",
//       "  return p + (getProject(a, b, p) - p) * (P_type)2.0;",
//       "}",
//       "",
//       "/* \u591a\u89d2\u5f62\u9762\u7a4d */",
//       "G_real getAreaPoly(vector<P> &g) {",
//       "  P_type res = 0;",
//       "  for (int i = 0; i < (int)g.size(); i++)",
//       "    res += cross(g[i], g[(i + 1) % g.size()]);",
//       "  return abs(res / 2.0);",
//       "}",
//       "",
//       "/* \u5186\u306e\u5171\u901a\u9762\u7a4d */",
//       "G_real getAreaCC(P c1, P_type r1, P c2, P_type r2) {",
//       "  G_real d = abs(c1 - c2);",
//       "  if (r1 + r2 <= d + P_eps) {",
//       "    return 0.0;",
//       "  } else if (d <= abs(r1 - r2) + P_eps) {",
//       "    G_real r = min(r1, r2);",
//       "    return r * r * M_PI;",
//       "  } else {",
//       "    G_real res = 0;",
//       "    for (int i = 0; i < 2; i++) {",
//       "      G_real rc = (G_real)(norm(c1 - c2) + r1 * r1 - r2 * r2) / (2 * d * r1);",
//       "      G_real theta = acos(rc) * 2;",
//       "      res += (theta - sin(theta)) * r1 * r1 / 2;",
//       "      swap(r1, r2);",
//       "      swap(c1, c2);",
//       "    }",
//       "    return res;",
//       "  }",
//       "}",
//       "",
//       "/* \u5186-\u76f4\u7dda(\u4e2d\u5fc3\u3068\u306e\u4e09\u89d2\u5f62) \u5171\u901a\u9762\u7a4d */",
//       "G_real getAreaCS(P c, P_type r, P a1, P a2) {",
//       "  if (min({abs(a1 - a2), abs(c - a1), abs(c - a2), r}) <= P_eps) return 0;",
//       "",
//       "  G_real res = 0;",
//       "  vector<P> vec = {a1};",
//       "  for (auto p : getCrosspointCS(c, r, a1, a2)) vec.push_back(p);",
//       "  vec.push_back(a2);",
//       "",
//       "  for (int i = 0; i + 1 < (int)vec.size(); i++) {",
//       "    P p1 = vec[i] - c, p2 = vec[i + 1] - c;",
//       "    if (max(abs(p1), abs(p2)) <= r + P_eps)",
//       "      res += cross(p1, p2) / 2.0;",
//       "    else",
//       "      res += r * r * arg(conj(p1) * p2) / 2.0;",
//       "  }",
//       "",
//       "  return res;",
//       "}",
//       "",
//       "/* \u5186-\u591a\u89d2\u5f62\u5171\u901a\u9762\u7a4d */",
//       "G_real getAreaPolyC(vector<P> &g, P c, P_type r) {",
//       "  G_real res = 0;",
//       "  for (int i = 0; i < (int)g.size(); i++)",
//       "    res += getAreaCS(c, r, g[i], g[(i + 1) % g.size()]);",
//       "  return abs(res);",
//       "}",
//       "",
//       "/* \u51f8\u591a\u89d2\u5f62\u306e\u5207\u65ad */",
//       "// \u76f4\u7ddaA\u3067\u5207\u65ad\u3057\u3001a1\u304b\u3089a2\u65b9\u5411\u306b\u898b\u305f\u3068\u304d\u306b\u76f4\u7ddaA\u306e\u5de6\u5074\u306b\u3067\u304d\u308b\u51f8\u591a\u89d2\u5f62\u3092\u8fd4\u3059",
//       "vector<P> convexCut(const vector<P> &g, P a1, P a2) {",
//       "  vector<P> res;",
//       "  P prev = *g.rbegin();",
//       "  for (P now : g) {",
//       "    if (ccw(a1, a2, prev) != -1) res.push_back(prev);",
//       "    int c = ccw(a1, a2, prev) * ccw(a1, a2, now);",
//       "    if (-4 < c && c < 0) {",
//       "      res.push_back(getCrosspointLL(prev, now, a1, a2)[0]);",
//       "    }",
//       "    prev = now;",
//       "  }",
//       "  return res;",
//       "}",
//       "",
//       "/* \u51f8\u591a\u89d2\u5f62\u306e\u76f4\u5f84(\u6700\u9060\u9802\u70b9\u5bfe\u9593\u8ddd\u96e2) */",
//       "// \u53cd\u6642\u8a08\u56de\u308a\u306e\u307f",
//       "G_real convexDiameter(const vector<P> &g) {",
//       "  int N = g.size(), is = 0, js = 0;",
//       "  for (int i = 1; i < N; i++) {",
//       "    if (imag(g[i]) > imag(g[is])) is = i;",
//       "    if (imag(g[i]) < imag(g[js])) js = i;",
//       "  }",
//       "",
//       "  G_real maxd = abs(g[is] - g[js]);",
//       "",
//       "  int i, maxi, j, maxj;",
//       "  i = maxi = is;",
//       "  j = maxj = js;",
//       "",
//       "  do {",
//       "    if (cross(g[(i + 1) % N] - g[i], g[(j + 1) % N] - g[j]) >= 0)",
//       "      j = (j + 1) % N;",
//       "    else",
//       "      i = (i + 1) % N;",
//       "",
//       "    if (abs(g[i] - g[j]) > maxd) {",
//       "      maxd = abs(g[i] - g[j]);",
//       "      maxi = i;",
//       "      maxj = j;",
//       "    }",
//       "  } while (i != is || j != js);",
//       "",
//       "  return maxd; /* farthest pair is {maxi, maxj}. */",
//       "}"
//     ],
//     "description": "Geometry Library"
//   },
//   "Geometry 3D Library": {
//     "prefix": "geo3d",
//     "body": [
//       "/* 3\u6b21\u5143\u5e7e\u4f55 */",
//       "",
//       "typedef double P_type;",
//       "typedef double G_real; //\u5b9f\u6570\u306e\u623b\u308a\u5024(float or double or long double)",
//       "const G_real P_eps = 1e-8; //\u6574\u6570\u306e\u6642\u306f\u30bc\u30ed",
//       "",
//       "struct P3 {",
//       "  P_type x, y, z;",
//       "  P3(P_type x = 0, P_type y = 0, P_type z = 0): x(x), y(y), z(z) {}",
//       "",
//       "  P3 operator-() const {",
//       "    return P3(-x, -y, -z);",
//       "  }",
//       "",
//       "  P3 operator+(const P3 &B) const {",
//       "    return P3(x + B.x, y + B.y, z + B.z);",
//       "  }",
//       "",
//       "  P3 operator-(const P3 &B) const {",
//       "    return P3(x - B.x, y - B.y, z - B.z);",
//       "  }",
//       "",
//       "  P3 operator*(P_type a) const {",
//       "    return P3(x * a, y * a, z * a);",
//       "  }",
//       "",
//       "  P3 operator/(P_type a) const {",
//       "    return P3(x / a, y / a, z / a);",
//       "  }",
//       "",
//       "  P3 &operator+=(const P3 &B) {",
//       "    x += B.x;",
//       "    y += B.y;",
//       "    z += B.z;",
//       "    return *this;",
//       "  }",
//       "",
//       "  P3 &operator-=(const P3 &B) {",
//       "    x -= B.x;",
//       "    y -= B.y;",
//       "    z -= B.z;",
//       "    return *this;",
//       "  }",
//       "",
//       "  P3 &operator*=(P_type a) {",
//       "    x *= a;",
//       "    y *= a;",
//       "    z *= a;",
//       "    return *this;",
//       "  }",
//       "",
//       "  P3 &operator/=(P_type a) {",
//       "    x /= a;",
//       "    y /= a;",
//       "    z /= a;",
//       "    return *this;",
//       "  }",
//       "",
//       "  bool operator<(const P3 &b) {",
//       "    if (abs(x - b.x) > P_eps) return x + P_eps < b.x;",
//       "    if (abs(y - b.y) > P_eps) return y + P_eps < b.y;",
//       "    return z + P_eps < b.z;",
//       "  }",
//       "};",
//       "",
//       "ostream &operator<<(ostream &st, const P3 &p) {",
//       "  return st << \"(\" << p.x << \", \" << p.y << \", \" << p.z << \")\";",
//       "}",
//       "",
//       "P_type dot(P3 a, P3 b) {",
//       "  return a.x * b.x + a.y * b.y + a.z * b.z;",
//       "}",
//       "",
//       "P3 cross(P3 a, P3 b) {",
//       "  P_type x = a.y * b.z - a.z * b.y;",
//       "  P_type y = a.z * b.x - a.x * b.z;",
//       "  P_type z = a.x * b.y - a.y * b.x;",
//       "  return P3(x, y, z);",
//       "}",
//       "",
//       "P_type norm(P3 a) {",
//       "  return dot(a, a);",
//       "}",
//       "",
//       "double abs(P3 a) {",
//       "  return sqrt(dot(a, a)); //sqrtl",
//       "}",
//       "",
//       "/* \u30d9\u30af\u30c8\u30eba, b\u306e\u6210\u3059\u89d2[0, pi] */",
//       "G_real arg(P3 a, P3 b) {",
//       "  return acos(dot(a, b) / abs(a) / abs(b)); //acosl",
//       "}",
//       "",
//       "/* \u70b9A\u306e\u5e73\u9762Pl\u3078\u306e\u6b63\u5c04\u5f71 */",
//       "P3 getProject(P3 a, P3 pl1, P3 pl2, P3 pl3) {",
//       "  P3 n = cross(pl2 - pl1, pl3 - pl1);",
//       "  return a - n * dot(n, a - pl1) / norm(n);",
//       "}",
//       "",
//       "/* \u76f4\u7ddaab\u3068\u70b9c\u306e\u8ddd\u96e2 */",
//       "G_real distanceLP(P3 a, P3 b, P3 c) {",
//       "  return abs(cross(b - a, c - a)) / abs(b - a);",
//       "}",
//       "",
//       "/* \u7dda\u5206ab\u3068\u70b9c\u306e\u8ddd\u96e2 */",
//       "G_real distanceSP(P3 a, P3 b, P3 c) {",
//       "  if (dot(b - a, c - a) <= P_eps) return abs(c - a);",
//       "  if (dot(a - b, c - b) <= P_eps) return abs(c - b);",
//       "  return abs(cross(b - a, c - a)) / abs(b - a);",
//       "}",
//       "",
//       "/* \u76f4\u7ddaA\u3068\u76f4\u7ddaB\u306e\u8ddd\u96e2 (\u672a\u691c\u8a3c) */",
//       "G_real distanceLL(P3 a1, P3 a2, P3 b1, P3 b2) {",
//       "  P3 n = cross(a2 - a1, b2 - b1);",
//       "  if (abs(n) <= P_eps) return distanceLP(a1, a2, b1); //\u5e73\u884c",
//       "  return abs(dot(n, b1 - a1)) / abs(n);",
//       "}",
//       "",
//       "/* \u7dda\u5206A\u3068\u7dda\u5206B\u306e\u8ddd\u96e2(\u672a\u691c\u8a3c) */",
//       "G_real distanceSS(P3 a1, P3 a2, P3 b1, P3 b2) {",
//       "  //\u306d\u3058\u308c\u306e\u4f4d\u7f6e",
//       "  P3 n = cross(a2 - a1, b2 - b1);",
//       "  if (abs(n) > P_eps) { // \u5e73\u884c\u3067\u306f\u306a\u3044",
//       "    n /= abs(n);",
//       "    G_real d = distanceLL(a1, a2, b1, b2);",
//       "    P3 p = n * dot(n, b1 - a1);",
//       "    P3 c1 = b1 + p, c2 = b2 + p;",
//       "",
//       "    P3 va = a2 - a1, vc = c2 - c1;",
//       "    bool f1 = dot(cross(va, c1 - a1), cross(va, c2 - a1)) < -P_eps;",
//       "    bool f2 = dot(cross(vc, a1 - c1), cross(vc, a2 - c1)) < -P_eps;",
//       "",
//       "    if (f1 && f2) return d;",
//       "  }",
//       "",
//       "  //\u305d\u306e\u4ed6",
//       "  return min({distanceSP(a1, a2, b1), distanceSP(a1, a2, b2),",
//       "    distanceSP(b1, b2, a1), distanceSP(b1, b2, a2)});",
//       "}",
//       "",
//       "/* \u70b9\u3068\u5e73\u9762Pl\u306e\u8ddd\u96e2 */",
//       "G_real distancePPl(P3 p, P3 pl1, P3 pl2, P3 pl3) {",
//       "  P3 n = cross(pl2 - pl1, pl3 - pl1);",
//       "  assert(abs(n) > P_eps); //3\u70b9\u304c\u540c\u4e00\u76f4\u7dda\u4e0a\u3067\u306a\u3044",
//       "  return abs(dot(p - pl1, n)) / abs(n);",
//       "}",
//       "",
//       "/* \u76f4\u7ddaA\u3068\u3001\u5e73\u9762Pl\u306e\u4ea4\u70b9 */",
//       "// verified: AOJ0115",
//       "vector<P3> getCrosspointLPl(P3 a1, P3 a2, P3 pl1, P3 pl2, P3 pl3) {",
//       "  P3 n = cross(pl2 - pl1, pl3 - pl1); //\u5e73\u9762\u306e\u6cd5\u7dda\u30d9\u30af\u30c8\u30eb",
//       "  if (abs(dot(n, a2 - a1)) <= P_eps)",
//       "    return {}; //\u5e73\u9762\u3068\u76f4\u7dda\u304c\u5e73\u884c",
//       "",
//       "  G_real s = dot(pl1 - a1, n), t = dot(a2 - pl1, n);",
//       "  P3 c = a1 + (a2 - a1) * (s / (s + t));",
//       "  return {c};",
//       "}",
//       "",
//       "/* \u7dda\u5206A\u3068\u3001\u5e73\u9762Pl\u306e\u4ea4\u70b9 */",
//       "// verified: AOJ0115",
//       "vector<P3> getCrosspointSPl(P3 a1, P3 a2, P3 pl1, P3 pl2, P3 pl3) {",
//       "  auto cps = getCrosspointLPl(a1, a2, pl1, pl2, pl3);",
//       "  if (cps.empty()) return {};",
//       "  if (norm(a1 - cps[0]) > norm(a1 - a2) + P_eps) return {};",
//       "  if (norm(a2 - cps[0]) > norm(a1 - a2) + P_eps) return {};",
//       "  return cps;",
//       "}",
//       "",
//       "/* \u76f4\u7ddaA, B\u306e\u4ea4\u70b9 */",
//       "vector<P3> getCrosspointLL(P3 a1, P3 a2, P3 b1, P3 b2) {",
//       "  if (distanceLL(a1, a2, b1, b2) > P_eps) return {};",
//       "  P3 a = a2 - a1, b = b2 - b1;",
//       "  a /= abs(a);",
//       "  b /= abs(b);",
//       "  P_type t = dot(a, b);",
//       "  if (abs(abs(t) - 1) < P_eps) return {}; //\u5e73\u884c",
//       "  return {a1 + a * dot(a1 - b1, a - b * t) / (t * t - 1)}; //\u306d\u3058\u308c\u306e\u4f4d\u7f6e\u306e\u3068\u304d\u306f\u3001A\u5074\u306e\u6700\u8fd1\u70b9",
//       "}"
//     ],
//     "description": "Geometry 3D Library"
//   },
//   "Line": {
//     "prefix": "line",
//     "body": [
//       "/* Line ax+bx+c=0 */",
//       "",
//       "// P(x, y)",
//       "",
//       "struct Line {",
//       "  P_type a, b, c;",
//       "",
//       "  Line(P_type a, P_type b, P_type c): a(a), b(b), c(c) {}",
//       "",
//       "  //2\u70b9(x1,y1),(x2,y2)\u3092\u901a\u308b\u76f4\u7dda",
//       "  Line(P_type x1, P_type y1, P_type x2, P_type y2): a(y1 - y2), b(x2 - x1), c(y1 * (x1 - x2) - x1 * (y1 - y2)) {}",
//       "",
//       "  // y\u5ea7\u6a19\u304b\u3089x\u5ea7\u6a19\u3092\u53d6\u5f97",
//       "  G_real x(double y) {",
//       "    return -(G_real)(b * y + c) / a;",
//       "  }",
//       "",
//       "  // x\u5ea7\u6a19\u304b\u3089y\u5ea7\u6a19\u3092\u53d6\u5f97",
//       "  G_real y(P_type x) {",
//       "    return -(G_real)(a * x + c) / b;",
//       "  }",
//       "",
//       "  // \u70b9p\u3068\u76f4\u7dda\u306e\u8ddd\u96e2",
//       "  G_real dist(P p) {",
//       "    return abs(a * p.real() + b * p.imag() + c) / sqrt(a * a + b * b);",
//       "  }",
//       "};",
//       "",
//       "/* \u5186\u306e\u5171\u901a\u63a5\u7dda */",
//       "",
//       "vector<Line> getCommonTangents(P c1, P_type r1, P c2, P_type r2) {",
//       "  vector<Line> res;",
//       "  c2 -= c1;",
//       "",
//       "  // \u5185\u5305",
//       "  if (abs(c2) + min(r1, r2) < max(r1, r2) - P_eps) return res;",
//       "",
//       "  for (int i = -1; i <= 1; i += 2) {",
//       "    for (int j = -1; j <= 1; j += 2) {",
//       "      P_type sr = r1 + r2 * i;",
//       "      P_type p = sqrt(norm(c2) - sr * sr) * j;",
//       "",
//       "      P_type xq = r1 * (c2.real() * sr + c2.imag() * p) / norm(c2);",
//       "      P_type yq = r1 * (c2.imag() * sr - c2.real() * p) / norm(c2);",
//       "",
//       "      res.push_back(Line(xq, yq, -r1 * r1 - c1.real() * xq - c1.imag() * yq));",
//       "    }",
//       "    if (abs(c2) < (r1 + r2) - P_eps) break; //\u5185\u63a5\u7dda\u7121\u3057",
//       "  }",
//       "",
//       "  return res;",
//       "}"
//     ],
//     "description": "Line"
//   },
//   "Convex Hull": {
//     "prefix": "convexhull",
//     "body": [
//       "/* ConvexHull(\u51f8\u5305) */",
//       "",
//       "vector<P> ConvexHull(vector<P> s) {",
//       "  vector<P> g;",
//       "  int m, n = (int)s.size();",
//       "",
//       "  if (n < 3) return s;",
//       "",
//       "  sort(s.begin(), s.end());",
//       "",
//       "  //\u8fba\u4e0a\u306e\u70b9\u3092\u542b\u307e\u306a\u3044\u3068\u304d\u306f\u3001ccw(*, *, *) <= 0 -> ccw(*, *, *) != 1",
//       "",
//       "  for (int i = 0; i < n; i++) {",
//       "    while ((m = g.size()) >= 2 && ccw(g[m - 2], g[m - 1], s[i]) <= 0) g.pop_back();",
//       "    g.push_back(s[i]);",
//       "  }",
//       "",
//       "  int t = (int)g.size();",
//       "",
//       "  for (int i = n - 2; i >= 0; i--) {",
//       "    while ((m = g.size()) > t && ccw(g[m - 2], g[m - 1], s[i]) <= 0) g.pop_back();",
//       "    g.push_back(s[i]);",
//       "  }",
//       "",
//       "  g.pop_back();",
//       "",
//       "  return g; //\u53cd\u6642\u8a08\u56de\u308a",
//       "}"
//     ],
//     "description": "Convex Hull"
//   },
//   "Trie": {
//     "prefix": "trie",
//     "body": [
//       "/* Trie */",
//       "",
//       "struct Trie {",
//       "  int val;",
//       "  Trie *next[26];",
//       "",
//       "  Trie(): val(0) { memset(next, 0, sizeof(next)); }",
//       "",
//       "  void insert(char *s, bool countPrefix = true) {",
//       "    if (countPrefix) val++; //\u63a5\u982d\u8f9e\u306e\u30ab\u30a6\u30f3\u30c8[default]",
//       "",
//       "    if (*s) {",
//       "      int al = *s - 'a';",
//       "      if (next[al] == NULL) next[al] = new Trie;",
//       "      next[al]->insert(s + 1, countPrefix);",
//       "    } else {",
//       "      if (!countPrefix) val++; //\u7d42\u7aef\u306e\u30ab\u30a6\u30f3\u30c8",
//       "    }",
//       "  }",
//       "",
//       "  int find(char *s) {",
//       "    if (*s) {",
//       "      int al = *s - 'a';",
//       "      return next[al] ? next[al]->find(s + 1) : 0;",
//       "    }",
//       "    return val;",
//       "  }",
//       "};"
//     ],
//     "description": "Trie"
//   },
//   "Aho Corasick": {
//     "prefix": "ahocora",
//     "body": [
//       "/* Aho Corasick */",
//       "",
//       "struct ACNode {",
//       "  int val;",
//       "  ACNode *next[26], *failure;",
//       "",
//       "  ACNode(): val(0) { memset(next, 0, sizeof(next)); }",
//       "",
//       "  void insert(char *s) {",
//       "    if (!*s) {",
//       "      val++;",
//       "      return;",
//       "    }",
//       "    int al = *s - 'a';",
//       "    if (next[al] == NULL) next[al] = new ACNode;",
//       "    next[al]->insert(s + 1);",
//       "  }",
//       "",
//       "  ACNode *nextNode(char c) {",
//       "    int al = c - 'a';",
//       "    if (next[al]) return next[al];",
//       "    return failure == this ? this : failure->nextNode(c);",
//       "  }",
//       "};",
//       "",
//       "struct AhoCorasick {",
//       "  ACNode *node;",
//       "",
//       "  AhoCorasick() { node = new ACNode; }",
//       "",
//       "  void insert(char *s) {",
//       "    node->insert(s);",
//       "  }",
//       "",
//       "  void build() {",
//       "    queue<ACNode *> que;",
//       "    que.push(node);",
//       "    node->failure = node;",
//       "",
//       "    while (que.size()) {",
//       "      ACNode *p = que.front();",
//       "      que.pop();",
//       "",
//       "      for (int i = 0; i < 26; i++) {",
//       "        if (p->next[i]) {",
//       "          ACNode *failure = p->failure;",
//       "          while (!failure->next[i] && failure != node)",
//       "            failure = failure->failure;",
//       "",
//       "          if (failure->next[i] && failure != p) {",
//       "            p->next[i]->failure = failure->next[i];",
//       "            p->next[i]->val += failure->next[i]->val;",
//       "          } else {",
//       "            p->next[i]->failure = node;",
//       "          }",
//       "          que.push(p->next[i]);",
//       "        }",
//       "      }",
//       "    }",
//       "  }",
//       "};"
//     ],
//     "description": "Aho Corasick"
//   },
//   "Recursive Descent Parsing": {
//     "prefix": "parsing",
//     "body": [
//       "/* \u518d\u5e30\u4e0b\u964d\u6cd5 */",
//       "// char *p = str; res = expr(p);",
//       "",
//       "int term(char*& s);",
//       "int number(char*& s);",
//       "int factor(char*& s);",
//       "int expr(char*& s);",
//       "",
//       "//\u6570",
//       "int number(char*& s) {",
//       "  int res = 0;",
//       "  while ('0' <= *s && *s <= '9')",
//       "    res = res * 10 + (*s++ - '0');",
//       "  return res;",
//       "}",
//       "",
//       "//\u4e57\u7b97\u9664\u7b97(\u512a\u5148\u9806\u4f4d:\u9ad8)",
//       "int term(char*& s) {",
//       "  int res = factor(s);",
//       "  while (1) {",
//       "    if (*s == '*')",
//       "      res *= factor(++s);",
//       "    else if (*s == '/')",
//       "      res /= factor(++s);",
//       "    else",
//       "      break;",
//       "  }",
//       "  return res;",
//       "}",
//       "",
//       "//\u62ec\u5f27\u304b\u6570",
//       "int factor(char*& s) {",
//       "  if (*s != '(') return number(s);",
//       "  int res = expr(++s);",
//       "  s++;",
//       "  return res;",
//       "}",
//       "",
//       "//\u5f0f(\u512a\u5148\u9806\u4f4d: \u4f4e)",
//       "int expr(char*& s) {",
//       "  int res = term(s);",
//       "  while (1) {",
//       "    if (*s == '+')",
//       "      res += term(++s);",
//       "    else if (*s == '-')",
//       "      res -= term(++s);",
//       "    else",
//       "      break;",
//       "  }",
//       "  return res;",
//       "}"
//     ],
//     "description": "Recursive Descent Parsing"
//   },
//   "SuffixArray/LCP": {
//     "prefix": "suffixarray",
//     "body": [
//       "/* SuffixArray (Source: \u87fb\u672c) */",
//       "",
//       "//O(N log^2 N)",
//       "//pos[i] := \u63a5\u982d\u8f9e\u306e\u958b\u59cb\u4f4d\u7f6e",
//       "//lcp[i] := lcp(s[pos[i]:n-1], s[pos[i-1]:n-1])",
//       "struct SuffixArray {",
//       "  vector<int> pos, lcp;",
//       "",
//       "  SuffixArray(const char *S) {",
//       "    int n = strlen(S), k;",
//       "    vector<int> rank(S, S + n), tmp(n);",
//       "    auto comp = [&](const int &i, const int &j) {",
//       "      if (rank[i] != rank[j]) return rank[i] < rank[j];",
//       "      return (i + k < n ? rank[i + k] : -1) < (j + k < n ? rank[j + k] : -1);",
//       "    };",
//       "",
//       "    pos.resize(n);",
//       "    iota(pos.begin(), pos.end(), 0);",
//       "",
//       "    for (k = 1; k < n; k *= 2) {",
//       "      sort(pos.begin(), pos.end(), comp);",
//       "      tmp[pos[0]] = 0;",
//       "      for (int i = 1; i < n; i++)",
//       "        tmp[pos[i]] = tmp[pos[i - 1]] + comp(pos[i - 1], pos[i]);",
//       "      for (int i = 0; i < n; i++)",
//       "        rank[i] = tmp[i];",
//       "    }",
//       "",
//       "    //LongestCommonPrefixArray",
//       "    lcp.resize(n);",
//       "    for (int i = 0; i < n; i++) rank[pos[i]] = i;",
//       "",
//       "    for (int i = 0, h = 0; i < n; i++) {",
//       "      if (rank[i] + 1 < n) {",
//       "        for (int j = pos[rank[i] + 1]; max(i, j) + h < n && S[i + h] == S[j + h]; h++)",
//       "          ;",
//       "        lcp[rank[i] + 1] = h;",
//       "        if (h > 0) h--;",
//       "      }",
//       "    }",
//       "  }",
//       "",
//       "  int operator[](int k) const {",
//       "    return pos[k];",
//       "  }",
//       "};"
//     ],
//     "description": "SuffixArray/LCP"
//   },
//   "KMP": {
//     "prefix": "kmp",
//     "body": [
//       "/* KMP */",
//       "",
//       "// A[i] := \u6587\u5b57\u5217S[0,i-1]\u306e\u63a5\u982d\u8f9e\u3068\u63a5\u5c3e\u8f9e\u304c\u6700\u5927\u4f55\u6587\u5b57\u4e00\u81f4\u3057\u3066\u3044\u308b\u304b (i-1\u672a\u6e80)",
//       "// len(A) == S.size() + 1",
//       "",
//       "void KMP(const char *S, int *A) {",
//       "  A[0] = -1;",
//       "  int j = -1, n = strlen(S);",
//       "  for (int i = 0; i < n; i++) {",
//       "    while (j >= 0 && S[i] != S[j]) j = A[j];",
//       "    j++;",
//       "",
//       "    //KMP",
//       "    //if (S[i+1] == S[j]) A[i+1] = A[j];",
//       "    //else A[i+1] = j;",
//       "",
//       "    //MP",
//       "    A[i + 1] = j;",
//       "  }",
//       "}"
//     ],
//     "description": "KMP"
//   },
//   "Manacher": {
//     "prefix": "manacher",
//     "body": [
//       "/* Manacher */",
//       "",
//       "// R[i] := \u6587\u5b57 i \u3092\u4e2d\u5fc3\u3068\u3059\u308b\u6700\u9577\u306e\u56de\u6587\u306e\u534a\u5f84( \u5168\u9577+1 / 2 )",
//       "// \u5076\u6570\u9577\u306f\u6587\u5b57\u9593\u306b\u30c0\u30df\u30fc\u3092\u5165\u308c\u308b(\u4f8b: a#b#a#c#b)",
//       "",
//       "void Manacher(const char *S, int *R) {",
//       "  int i = 0, j = 0, k, n = strlen(S);",
//       "  while (i < n) {",
//       "    while (i >= j && i + j < n && S[i - j] == S[i + j]) j++;",
//       "    R[i] = j;",
//       "    for (k = 1; i >= k && i + k < n && k + R[i - k] < j; k++) R[i + k] = R[i - k];",
//       "    i += k;",
//       "    j -= k;",
//       "  }",
//       "}"
//     ],
//     "description": "Manacher"
//   },
//   "Zalgorithm": {
//     "prefix": "zalgo",
//     "body": [
//       "/* Zalgorithm */",
//       "",
//       "// A[i] := S \u3068 S[i:|S|-1] \u306e\u6700\u9577\u5171\u901a\u63a5\u982d\u8f9e\u306e\u9577\u3055",
//       "",
//       "void Zalgorithm(const char *S, int *A) {",
//       "  int i = 1, j = 0, k, n = strlen(S);",
//       "  A[0] = n;",
//       "  while (i < n) {",
//       "    while (i + j < n && S[j] == S[i + j]) j++;",
//       "    A[i] = j;",
//       "    if (j == 0) {",
//       "      i++;",
//       "      continue;",
//       "    }",
//       "    for (k = 1; i + k < n && k + A[k] < j; k++) A[i + k] = A[k];",
//       "    i += k;",
//       "    j -= k;",
//       "  }",
//       "}"
//     ],
//     "description": "Zalgorithm"
//   },
//   "Rolling Hash": {
//     "prefix": "rollinghash",
//     "body": [
//       "/* Rolling Hash */",
//       "// n = 9999991, 10000019, 924844033, 1012924417",
//       "",
//       "struct RollingHash {",
//       "  int N, base;",
//       "  vector<ll> hash, pow;",
//       "",
//       "  template<typename Type>",
//       "  RollingHash(int base, int n, Type *arr): N(n), base(base), hash(n + 1), pow(n + 1) {",
//       "    hash[0] = 0;",
//       "    pow[0] = 1;",
//       "    for (int i = 0; i < N; i++) {",
//       "      hash[i + 1] = (hash[i] + arr[i]) * base % mod;",
//       "      pow[i + 1] = pow[i] * base % mod;",
//       "    }",
//       "  }",
//       "",
//       "  // get [l,r)",
//       "  ll getHash(int l, int r) {",
//       "    return (mod + hash[r] - hash[l] * pow[r - l] % mod) % mod;",
//       "  }",
//       "};"
//     ],
//     "description": "Rolling Hash"
//   },
//   "Fairfield": {
//     "prefix": "fairfield",
//     "body": [
//       "/* \u897f\u66a61\u5e741\u67081\u65e5\u304b\u3089\u306e\u7d4c\u904e\u65e5\u6570\u8a08\u7b97 */",
//       "ll Fairfield(ll y, int m, int d) {",
//       "  if (m <= 2) {",
//       "    y--;",
//       "    m += 12;",
//       "  }",
//       "",
//       "  ll dy = 365LL * (y - 1);",
//       "  int dl = y / 4 - y / 100 + y / 400;",
//       "  int dm = (306 * m - 324) / 10;",
//       "  return dy + dl + dm + d - 1;",
//       "}"
//     ],
//     "description": "Fairfield"
//   },
//   "Zeller": {
//     "prefix": "zeller",
//     "body": [
//       "/* \u66dc\u65e5\u8a08\u7b97 (0\u65e5\u66dc\u65e5 - 6\u571f\u66dc\u65e5)\u3000*/",
//       "int Zeller(ll y, int m, int d) {",
//       "  if (m <= 2) {",
//       "    y--;",
//       "    m += 12;",
//       "  }",
//       "  return (y + y / 4 - y / 100 + y / 400 + (13 * m + 8) / 5 + d) % 7;",
//       "}"
//     ],
//     "description": "Zeller"
//   },
//   "Leap Year": {
//     "prefix": "isuruu",
//     "body": [
//       "/* \u3046\u308b\u3046\u5e74 */",
//       "bool is_uruu(int y) {",
//       "  return y % 4 == 0 && (y % 100 != 0 || y % 400 == 0);",
//       "}"
//     ],
//     "description": "Leap Year"
//   },
//   "XOR Shift": {
//     "prefix": "xorshift",
//     "body": [
//       "/* Xorshift */",
//       "#include <cstdlib>",
//       "",
//       "typedef unsigned long long ull;",
//       "typedef unsigned int uint;",
//       "",
//       "uint xor64() {",
//       "  static ull x = ((ull)rand() << 32) + rand();",
//       "  x = x ^ (x << 13);",
//       "  x = x ^ (x >> 7);",
//       "  return x = x ^ (x << 17);",
//       "}",
//       "",
//       "ull xor64ll() {",
//       "  static ull x = ((ull)rand() << 32) + rand();",
//       "  x = x ^ (x << 7);",
//       "  return x = x ^ (x >> 9);",
//       "}",
//       "",
//       "uint xor128() {",
//       "  static uint x = 123456789;",
//       "  static uint y = 362436069;",
//       "  static uint z = 521288629;",
//       "  static uint w = rand();",
//       "  uint t;",
//       "",
//       "  t = x ^ (x << 11);",
//       "  x = y;",
//       "  y = z;",
//       "  z = w;",
//       "  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));",
//       "}"
//     ],
//     "description": "XOR Shift"
//   },
//   "ModInt": {
//     "prefix": "modint",
//     "body": [
//       "template<int M = mod>",
//       "struct ModInt {",
//       "  using ll = long long;",
//       "  ll val;",
//       "",
//       "  ModInt(ll x = 0): val(x >= 0 ? x % M : (x % mod + mod) % mod) {}",
//       "",
//       "  explicit operator bool() const { return val != 0; }",
//       "",
//       "  ModInt operator+() const { return *this; }",
//       "  ModInt operator-() const { return ModInt(-val); }",
//       "",
//       "  ModInt operator+(const ModInt &rhs) const { return ModInt(*this) += rhs; }",
//       "  ModInt operator-(const ModInt &rhs) const { return ModInt(*this) -= rhs; }",
//       "  ModInt operator*(const ModInt &rhs) const { return ModInt(*this) *= rhs; }",
//       "  ModInt operator/(const ModInt &rhs) const { return ModInt(*this) /= rhs; }",
//       "",
//       "  bool operator==(const ModInt &rhs) const { return val == rhs.val; }",
//       "  bool operator!=(const ModInt &rhs) const { return val != rhs.val; }",
//       "  bool operator<(const ModInt &rhs) const { return val < rhs.val; }",
//       "  bool operator>(const ModInt &rhs) const { return val > rhs.val; }",
//       "  bool operator<=(const ModInt &rhs) const { return val <= rhs.val; }",
//       "  bool operator>=(const ModInt &rhs) const { return val >= rhs.val; }",
//       "",
//       "  ModInt operator++() { return *this += 1; }",
//       "  ModInt operator--() { return *this -= 1; }",
//       "  ModInt operator++(int) { return ++*this, *this - 1; }",
//       "  ModInt operator--(int) { return --*this, *this + 1; }",
//       "",
//       "  ModInt &operator+=(const ModInt &rhs) {",
//       "    val += rhs.val;",
//       "    if (val >= M) val -= M;",
//       "    return *this;",
//       "  }",
//       "  ModInt &operator-=(const ModInt &rhs) {",
//       "    val -= rhs.val;",
//       "    if (val < 0) val += M;",
//       "    return *this;",
//       "  }",
//       "  ModInt &operator*=(const ModInt &rhs) {",
//       "    val = val * rhs.val % M;",
//       "    return *this;",
//       "  }",
//       "  ModInt &operator/=(ModInt rhs) {",
//       "    for (int exp = M - 2; exp; exp /= 2) {",
//       "      if (exp % 2) *this *= rhs;",
//       "      rhs *= rhs;",
//       "    }",
//       "    return *this;",
//       "  }",
//       "",
//       "  friend ostream &operator<<(ostream &os, const ModInt &rhs) {",
//       "    return os << rhs.val;",
//       "  }",
//       "",
//       "  friend istream &operator>>(istream &is, ModInt &rhs) {",
//       "    ll x;",
//       "    is >> x;",
//       "    rhs = ModInt(x);",
//       "    return is;",
//       "  }",
//       "};"
//     ],
//     "description": "ModInt"
//   },
//   "Coordinate Compression": {
//     "prefix": "compress",
//     "body": [
//       "/* Coordinate Compression */",
//       "",
//       "template<typename T>",
//       "map<T, int> compress(vector<T> &vec) {",
//       "  sort(vec.begin(), vec.end());",
//       "  vec.erase(unique(vec.begin(), vec.end()), vec.end());",
//       "",
//       "  map<T, int> dict;",
//       "  for (int i = 0; i < (int)vec.size(); i++) {",
//       "    dict[vec[i]] = i;",
//       "  }",
//       "  return dict;",
//       "}"
//     ],
//     "description": "Coordinate Compression"
//   },
//   "Dx Dy": {
//     "prefix": "dxdy",
//     "body": [
//       "int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1};",
//       "int dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};",
//       "char dirchar[] = \"DURL\"; // \"SNWE\""
//     ],
//     "description": "Dx Dy"
//   }
// }